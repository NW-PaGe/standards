[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "\n\nNORTHWEST PATHOGEN GENOMICS CENTER OF EXCELLENCE\n\nPolicies and Guidelines\n",
    "section": "",
    "text": "NORTHWEST PATHOGEN GENOMICS CENTER OF EXCELLENCE\n\nPolicies and Guidelines\n\nThis is a static website documenting the policies and guidelines for public Github use at the Pacific Northwest Genomic Center of Excellence. Scroll below to see overviews on Github, Azure, and AWS policies.\nGet started\n\n\n\n\n\n\n  \n\n\n\n\nGithub Policies\n\nRepo security rules \nLicensing \nTemplates and guides \n\ngh guides\n\n\n\nAWS Policies\n\nRepo AWS rules \nDocumentation \nUser guides \n\naws guides\n\n\n\nAzure Policies\n\nRepo Azure/Databricks rules \nDocumentation \nUser guides \n\nazure guides"
  },
  {
    "objectID": "gh/how_to.html",
    "href": "gh/how_to.html",
    "title": "Repo Documentation",
    "section": "",
    "text": "This site was created using Quarto, Github, and uses a Github Action to automatically render when a commit is pushed to the main branch of this repository.\nQuarto is a framework for creating documentation, slideshows, articles, blogs, books and websites using markdown. It can execute R, Python and other programming languages within the document.\nGithub Actions uses a .yml file in the repository to trigger an action based on a certain event. In this case, when a commit is pushed to the main branch the .yml will trigger this Quarto website to render to the gh-pages branch of the repository and publish the github page. This section will give details on how to\n\nCreate the website\nCreate, edit, and troubleshoot the Github Action to render the site",
    "crumbs": [
      "Github",
      "Tutorials",
      "Repo Documentation"
    ]
  },
  {
    "objectID": "gh/how_to.html#editadd-sections-and-chapters",
    "href": "gh/how_to.html#editadd-sections-and-chapters",
    "title": "Repo Documentation",
    "section": "Edit/Add Sections and Chapters",
    "text": "Edit/Add Sections and Chapters\nTo add a section, open up the _quarto.yml file and scroll to the navbar section\n\n\n\n_quarto.yml\n\nproject:\n  type: website\nwebsite:\n  title: \"COE Github Standards\"\n  search: true\n  \n  navbar: \n    background: primary\n    left: \n      - text: Home\n        href: index.qmd\n      - text: Github Organization Standards\n        menu: \n          - href: std/security.qmd\n            text: \"0: Security Standards\"\n          - href: std/lic.qmd\n            text: \"1: Choosing a License\"\n          - href: std/templates.qmd\n            text: \"2: Org Policy Setting\"\n\n\n\nThis is where all of the qmd files are sourced and the instructions on how to format and style the navigation bar in the website.\nCurrently, the project is set up to have each section have it’s own drop down menu in the navbar. In a section, use - href: to specify a file and text: to give the file a custom name in the website.\nEach chapter exists within a sub-folder, so to add a chapter make sure create the qmd in its sub-folder and then reference the sub-folder and chapter in the .yml. For example, if you make a new chapter called new-chapter.qmd and it exists in the covid section/sub-folder, you need to reference it in the .yml file like: covid/new-chapter.qmd",
    "crumbs": [
      "Github",
      "Tutorials",
      "Repo Documentation"
    ]
  },
  {
    "objectID": "gh/how_to.html#website-style",
    "href": "gh/how_to.html#website-style",
    "title": "Repo Documentation",
    "section": "Website Style",
    "text": "Website Style\nYou can customize many aspects of the website in the .yml file itself with the format: function. There are a ton of themes included in Quarto here and you can also add a custom css and/or scss file to your project. I think you can even go super in depth and customize the javascript components of the site, but I’m not entirely sure how to do that yet. This website has a ton of custom css components with Quarto, and possibly uses custom javascript, so it could be a place to start if you’re interested. Basically, you need to embed the css file into your _quarto.yml file\n\n\n\n_quarto.yml\n\nformat:\n  html:\n    theme: \n      - cosmo\n      - assets/styles.scss\n    scss: assets/styles.scss\n    # css: styles.css\n    toc: true\n    highlight-style: assets/custom.theme",
    "crumbs": [
      "Github",
      "Tutorials",
      "Repo Documentation"
    ]
  },
  {
    "objectID": "gh/how_to.html#open-the-r-project",
    "href": "gh/how_to.html#open-the-r-project",
    "title": "Repo Documentation",
    "section": "Open the R project",
    "text": "Open the R project\nThis is a Quarto website that is contained in a .rproj file path. The R project contains all the documents used to create this website. Begin by opening the R project when should be in your local clone under C:\\Users\\XXXXXXX\\Projects\\Sequencing_2.0\\sequencing_documentation\\sequencing_documentation.Rproj",
    "crumbs": [
      "Github",
      "Tutorials",
      "Repo Documentation"
    ]
  },
  {
    "objectID": "gh/how_to.html#open-the-files",
    "href": "gh/how_to.html#open-the-files",
    "title": "Repo Documentation",
    "section": "Open the files",
    "text": "Open the files\nThis project has .qmd files (Quarto Markdown files) that each represent a chapter in the website. All of the .qmd files are knitted together (using R knitr) which compiles all of the files to be sourced into htmls.\nThis website is set up to have each major section contain multiple chapters. To open a chapter, the bottom right pane in your R Studio window should contain folders for each section, highlighted below\n\n$ tree /f\nC:.\n│   .gitignore\n│   about.qmd\n│   index.qmd\n│   standards.Rproj\n│   _quarto.yml\n│\n├───assets\n│       custom.theme\n│       styles.css\n│       styles.scss\n│\n├───std\n│   │   creds.qmd\n│   │   lic.qmd\n│   │   public_code.qmd\n│   │   security.qmd\n│   │   templates.qmd\n│   │\n│   └───images\n│\n├───tools\n│   │   how_to.qmd\n│   │   iac.qmd\n│   │   link_code.qmd\n│   │   readme.qmd\n│   │   release.qmd\n│   │   renv.qmd\n│   │   teams.qmd\n│   │\n│   └───images\n\nError in running command bash\n\n\n\nThe .qmd files are inside of these folders. Select one to edit.",
    "crumbs": [
      "Github",
      "Tutorials",
      "Repo Documentation"
    ]
  },
  {
    "objectID": "gh/how_to.html#commit-changes",
    "href": "gh/how_to.html#commit-changes",
    "title": "Repo Documentation",
    "section": "Commit changes",
    "text": "Commit changes\nOnce you’re done editing, push the change to the main branch (or make a new branch, and then a pull request for the main branch). More one this in the git chapter",
    "crumbs": [
      "Github",
      "Tutorials",
      "Repo Documentation"
    ]
  },
  {
    "objectID": "gh/how_to.html#example-yaml-workflow",
    "href": "gh/how_to.html#example-yaml-workflow",
    "title": "Repo Documentation",
    "section": "Example YAML Workflow",
    "text": "Example YAML Workflow\nThe .yml workflow for this project looks something like this:\non: is a tag indicating when the action will run. Right now it will run when any code gets pushed to the main branch in the documentation folder or lineages_public_repo.R script\n\n\n\nquarto-publish.yml\n\non: \n  push:\n    branches:\n      - main\n    paths:\n      - documentation/**\n      - lineages_public_repo.R\n\n\njobs: is a tag that tells a Github virtual machine what to run and what operating system to run it on. In this case ubuntu with the latest version. This can be windows, linux or macOS.\n\n\n\nquarto-publish.yml\n\nname: Render and Publish\n\njobs:\n  build-deploy:\n    runs-on: ubuntu-latest\n\n\n\nNow we have the steps:\n\nenv will find the renv folder\nuses: actions/checkout@v3 will refresh the repo and pull the latest changes\nuses: quarto-dev/quarto-actions/setup@v2 will install quarto\nuses: actions/cache@v1 and the code below it will set up renv and use the cached packages to install them onto the Github virtual machine\n\n\n\n\nquarto-publish.yml\n\n    env:\n      RENV_PATHS_ROOT: ~/.cache/R/renv\n      \n    steps:\n      - name: Check out repository\n        uses: actions/checkout@v3\n        \n      - name: Set up Quarto\n        uses: quarto-dev/quarto-actions/setup@v2\n        \n      - name: Prep CURL install\n        run: sudo apt-get update\n\n      - name: Install CURL Headers\n        run: sudo apt-get install libcurl4-openssl-dev\n\n      # - name: Setup Renv\n      #   uses: r-lib/actions/setup-renv@v2\n  \n      - name: Cache packages\n        uses: actions/cache@v1\n        with:\n          path: ${{ env.RENV_PATHS_ROOT }}\n          key: ${{ runner.os }}-renv-${{ hashFiles('**/renv.lock') }}\n          restore-keys: |\n            ${{ runner.os }}-renv-\n      \n      - name: Restore packages\n        shell: Rscript {0}\n        run: |\n          if (!requireNamespace(\"renv\", quietly = TRUE)) install.packages(\"renv\")\n          renv::restore()\n\n\n\nAnd finally,\n\nuses: quarto-dev/quarto-actions/publish@v2 will render the site by running quarto render\nwith: target: gh-pages path: documentation/_site lets you know which branch and path to render the site to\n\n\n\n\nquarto-publish.yml\n\n      - name: Publish to GitHub Pages (and render)\n        uses: quarto-dev/quarto-actions/publish@v2\n        with:\n          target: gh-pages\n          path: documentation/_site\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # this secret is always available for github actions",
    "crumbs": [
      "Github",
      "Tutorials",
      "Repo Documentation"
    ]
  },
  {
    "objectID": "gh/how_to.html#using-renv-in-the-gh-action",
    "href": "gh/how_to.html#using-renv-in-the-gh-action",
    "title": "Repo Documentation",
    "section": "Using renv in the GH Action",
    "text": "Using renv in the GH Action\nIf you need to constantly update your website with code chunk, this is the best way to do it. It is also probably safer and better than the _freeze way, but it requires a better understanding of Github Actions and virtual environments.\nrenv is an R package for creating a project level virtual environment. In other words, renv will create project specific folders that contain the specific R package versions you use in an project. More on virtual environments here\nTo use renv in a Github Action, you can put\n\n\n\n\nquarto-publish.yml\n\n- name: Setup Renv\n  uses: r-lib/actions/setup-renv@v2\n\n\n\nor use the renv cache code in the yaml section above",
    "crumbs": [
      "Github",
      "Tutorials",
      "Repo Documentation"
    ]
  },
  {
    "objectID": "gh/how_to.html#using-a-_freeze-file",
    "href": "gh/how_to.html#using-a-_freeze-file",
    "title": "Repo Documentation",
    "section": "Using a _freeze file",
    "text": "Using a _freeze file\nIf you only need to execute the code once or just need to render a non-executable code chunk once, make sure you have this code in your _quarto.yml file:\n\n\n\n\n_quarto.yml\n\nexecute:\n  error: true\n  freeze: true\n\n\n\nand then run this in your terminal window:\nquarto render name-of-specific-document-or-chapter.qmd\nThis will render that specific document in the website, execute code chunks if they are set to execute (eval: true) and then it will create a _freeze file. The _freeze file will save a snapshot of that specific document and not re-render it in the Github Action. This means you can render other parts of the website, but any files in the _freeze folder will stay the same as they are in the freeze. If you need to make changes to a freeze document, run the quarto render code again after making changes.\nThis is also documented in the Quarto dev documentation",
    "crumbs": [
      "Github",
      "Tutorials",
      "Repo Documentation"
    ]
  },
  {
    "objectID": "gh/how_to.html#troubleshooting",
    "href": "gh/how_to.html#troubleshooting",
    "title": "Repo Documentation",
    "section": "Troubleshooting",
    "text": "Troubleshooting\nSo you did these steps:\n\nCreate the quarto-publish.yml\nRun quarto publish gh-pages in the terminal\nPush all the files in your git to the main branch\n\nIf this works on your first try then the universe is taking extra special care of you.\nIf not, you are like the rest of us poor souls:/\n\nThe first thing I would check is the error in your Github repo’s Action tab.\nIf the error is something like jsonlite not installed or some package not installed then it most likely means your are trying to commit a chunk of code in the documentation. Even if you are not executing the code, Github Actions will punish you. There are a couple options to fix this, depending on your priorities.\n\nIf you don’t care about executing your code and/or only need to push that part of the script once, consider using the _freeze option\nIf you need to execute code or need to programmtically render the document with code chunks often, consider using renv or a similar package installation method",
    "crumbs": [
      "Github",
      "Tutorials",
      "Repo Documentation"
    ]
  },
  {
    "objectID": "gh/release.html",
    "href": "gh/release.html",
    "title": "Release Cycles",
    "section": "",
    "text": "Summary\n\nGithub Releases\nHelps devs and end users\nChangelogs and semantic versioning\nAutomate the release process",
    "crumbs": [
      "Github",
      "Tutorials",
      "Release Cycles"
    ]
  },
  {
    "objectID": "gh/release.html#github-action-for-auto-releases",
    "href": "gh/release.html#github-action-for-auto-releases",
    "title": "Release Cycles",
    "section": "Github Action for auto releases",
    "text": "Github Action for auto releases\nI recommend first creating a test repo for this. In the repo, create a Github Action workflow called changelog.yml. You can copy the full file below:\n\n\n\n.github/workflows/changelog.yml\n\nname: Changelog\non:\n  push:\n    branches:\n      - main\n\njobs:\n  changelog:\n    runs-on: ubuntu-latest\n    \n    permissions:\n      # write permission is required to create a github release\n      contents: write\n\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Conventional Changelog Action\n        id: changelog\n        uses: TriPSs/conventional-changelog-action@v3\n        with:\n          github-token: ${{ secrets.github_token }}\n          create-summary: true\n\n      - name: Create Release\n        uses: actions/create-release@v1\n        if: ${{ steps.changelog.outputs.skipped == 'false' }}\n        env:\n          GITHUB_TOKEN: ${{ secrets.github_token }}\n        with:\n          prerelease: false\n          tag_name: ${{ steps.changelog.outputs.tag }}\n          release_name: ${{ steps.changelog.outputs.tag }}\n          body: ${{ steps.changelog.outputs.clean_changelog }}",
    "crumbs": [
      "Github",
      "Tutorials",
      "Release Cycles"
    ]
  },
  {
    "objectID": "gh/contribute.html",
    "href": "gh/contribute.html",
    "title": "Contribution Guide",
    "section": "",
    "text": "Summary\n\nThe Northwest Pathogen Genomics Center of Excellence (NW-PaGe) uses a public Github organization to host our code.\nIf you want to contribute to the organization, please read this guide and our security guidelines.\n\n\nYou will need Git and Github to make code contributions:\n\nGit is a version control software.\nGithub is a platform for developers that utilizes Git\nIn order to contribute to this organization you must have Git installed and a Github account\n\n\nGit Basics\n\nYou need to install Git on your machine follow here for help.\nFor a tutorial on how Git works, follow our Git page here\n\n\n\nGithub Basics\n\nGo to the Github website to create an account.\nBookmark the NW-PaGe Github Org\n\n\n\nContributing\nThere are multiple ways to contribute to a Github repo, whether it is to report a bug, request a feature, or actively contribute to the code base.\n\nBug ReportFeature RequestDiscussionsContribute Code\n\n\nTo report a bug,\n\nclick on a repo and click on the Issues tab.\nclick the New issue button\nclick on the Bug Report tab\n\nFrom here you will need to fill out the bug report along with steps to reproduce the behavior you’re seeing.\n\n\nDo you have a feature that you want included in the code base?\n\nclick on a repo and click on the Issues tab.\nclick the New issue button\nclick on the Feature Request tab\n\nFrom here you will need to fill out the feature request along with details\n\n\nThere is a discussions tab in our Github org. You can start discussions, ask questions, and share ideas here.\n\n\nTo contribute to a public repo in our Github org, please contact the repo owner to request read/write access. If you want to create a repo in the org, please contact frank.aragona@doh.wa.gov.\nBefore contributing any code, please read our security policies. There you will find our repo rules and instructions on how to set up pre-commit hooks.\n\n\n\n\n\nCloning a Repo\nTo make a local clone of a repo, click on the green Code button when you’re in the main repo’s web page. In the local tab there are multiple ways to clone. For most of our work, I suggest creating an SSH key. If you are new to git/Github and on a Windows machine, I recommend installing the Github Desktop app and following the instructions below.\n\nHTTPSSSHGitHub CLIOpen with GitHub Desktop\n\n\nCloning via HTTPS is a relatively quick process.\n\nStart by navigating to the repo in Github and selecting the Code button:\n\n\n\nCopy the path that starts with https://, in this case it’s https://github.com/NW-PaGe/standards.git\nIn a terminal/command prompt, navigate to a folder of your choice (in windows I would make a folder called Projects here: C:/Users/&lt;username&gt;/Projects)\n\n\n\n\n\nterminal\n\ncd C:/Users/&lt;your_username&gt;/Projects\n\n\n\n\nUse git clone and replace the https://github.com/NW-PaGe/standards.git with your path:\n\n\n\n\n\nterminal\n\ngit clone https://github.com/NW-PaGe/standards.git\n\n\n\n\nCheck if things ran by executing this code:\n\n\n\n\n\nterminal\n\ngit status\n\n\n\nNOTE: the HTTPS method is good but it will require you to enter your username and a token every time you push a commit to the remote repo in Github. You will need to create a Personal Access Token (PAT) whenever you want to make a commit. If this is annoying to you, use the SSH or Github Desktop App methods.\n\nMake a PAT\nHere’s a guide on making a PAT\n\nClick on you Github profile icon in the upper right\nClick Settings\nScroll down to Developer Settings\nSelect Personal access tokens (classic) and then Generate new token\nWhen you make a commit you will need to input this personal access token when it asks for your password.\n\nDo not store this token anywhere! Especially make sure it is not stored in your repo. This has tons of security risks and needs to be for singular use only\n\n\n\nSSH is an excellent option for cloning a repo. It is similar to using an identifier to tell Github that you are, in fact, you. This video below is a great resource on how to set up the key. I will also write out the steps in the video below. Also, see the Github documentation for more information.\n\n\nIn a terminal, write the following and replace the email with your email:\n\n\n\n\n\nterminal\n\nssh-keygen -t ed25519 -C your@email.com\n\n\n\n\nIt should then ask if you want to make a passphrase. I recommend doing this\nGet the pid\n\n\n\n\n\nterminal\n\neval \"$(ssh-agent -s)\"\n\n\n\n\nMake a config file\n\n\n\n\n\nterminal\n\ntouch ~/.ssh/config\n\n\n\n\nIf the file doesn’t open, you can open it like this\n\n\n\n\n\nterminal\n\nnano ~/.ssh/config\n\n\n\n\nAdd this to the config file. it will use your passkey and recognize you\n\n\n\n\n\nssh/config\n\nHost *\n  IgnoreUnknown AddKeysToAgent,UseKeychain\n  AddKeysToAgent yes\n  IdentityFile ~/.ssh/id_ed25519\n  UseKeychain yes\n\n\n\nTo save this file in nano, on your keyboard write CRTL+O then ENTER to save the file. Then CTRL+X to exit back to the terminal. You can also open this file through a notepad or other software. You could also search for the file in your file explorer and edit it in notepad if that is easier.\n\nAdd the identity\n\n\n\n\n\nterminal\n\nssh-add ~/.ssh/id_ed25519\n\n\n\n\nIn Github, go to your profile and the SSH + GPG Keys section\nClick SSH Keys, add a title, and in the key location write your key. You can find your key in your terminal by writing:\n\n\n\n\n\nterminal\n\ncat ~/.ssh/id_ed25519.pub\n\n\n\nCopy the whole output including your email and paste it into the Github key location\n\nTest it by writing this:\n\n\n\n\n\nterminal\n\nssh -T git@github.com\n\n\n\n\nUse the key to clone a repo.\n\nNow you can clone a repo using the SSH key. Copy the SSH path and write this (replace the string after clone with your repo of choice):\n\n\n\n\nterminal\n\ngit clone git@github.com:org/reponame.git\n\n\n\n\n\nThe GitHub CLI is an excellent tool for not just cloning your repo, but for managing repositories and organizations from a terminal.\n\nWindowsWSL/Linux\n\n\nTo install the CLI in Windos, I follwed the instructions provided in the Github CLI repo.\nI normally install commands using Scoop, but you have many options here.\n\nPaste this code into a powershell window and execute it\n\n\n\n\n\npowershell\n\nwinget install --id GitHub.cli\n\n\n\n\nNow update the package\n\n\n\nwinget upgrade --id GitHub.cli\n\n\n\nYou will need to authorize your github account like this:\n\n\n\ngh auth login\n\n\n\nIt will ask you to authorize in a browser or with a personal access token\n\nI created a personal access token.\n\nNow you can clone a repo like this:\n\n\n\n\n\nterminal\n\ngh repo clone org/repo-name\n\n\n\nYou can also now do some cool things with your org/repo like searching for strings, creating issues, and more. For example, here are the issues in this repo:\n\n\n\n\nterminal\n\ngh issue list\n\n\n\n\n\n\noutput\n\nShowing 3 of 3 open issues in NW-PaGe/standards\n\nID  TITLE                                      LABELS         UPDATED           \n#7  add .gitignore documentation                              about 2 months ago\n#3  Make sure all references are added to ...  documentation  about 5 months ago\n#2  Fix cross reference links                  documentation  about 5 months ago\n\n\n\n\nTo install in a linux terminal, I’m following the instructions provided in the Github CLI repo.\n\nPaste this code into your bash terminal and execute it.\n\n\n\n\nterminal\n\n(type -p wget &gt;/dev/null || (sudo apt update && sudo apt-get install wget -y)) \\\n&& sudo mkdir -p -m 755 /etc/apt/keyrings \\\n&& wget -qO- https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo tee /etc/apt/keyrings/githubcli-archive-keyring.gpg &gt; /dev/null \\\n&& sudo chmod go+r /etc/apt/keyrings/githubcli-archive-keyring.gpg \\\n&& echo \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main\" | sudo tee /etc/apt/sources.list.d/github-cli.list &gt; /dev/null \\\n&& sudo apt update \\\n&& sudo apt install gh -y\n\n\n\nThen upgrate the command with the code below\n\n\n\n\n\nterminal\n\nsudo apt update\nsudo apt install gh\n\n\n\n\nYou now need to authorize yourself as a user.\n\n\n\n\n\nterminal\n\ngh auth login\n\n\n\n\nIt will ask you to authorize in a browser or with a personal access token\n\nI created a personal access token. In linux there are some issues with the command and using a browser fyi.\n\nNow you can clone a repo like this:\n\n\n\n\n\nterminal\n\ngh repo clone org/repo-name\n\n\n\nYou can also now do some cool things with your org/repo like searching for strings, creating issues, and more. For example, here are the issues in this repo:\n\n\n\n\nterminal\n\ngh issue list\n\n\n\n\n\n\noutput\n\nShowing 3 of 3 open issues in NW-PaGe/standards\n\nID  TITLE                                      LABELS         UPDATED           \n#7  add .gitignore documentation                              about 2 months ago\n#3  Make sure all references are added to ...  documentation  about 5 months ago\n#2  Fix cross reference links                  documentation  about 5 months ago\n\n\n\n\n\n\n\nIf you’re new to Git or Github and are using a Windows machine, the GitHub Desktop app is a great option for managing git workflows.\n\nInstall the app\nYou will need to authenticate your account\nNow you should be able to clone repos through the app. In Github, when you click on the Code tab you will see the option to open in Github Desktop:\n\n\nThis will open up the desktop app and let you choose a file path for your Github repos. I recommend putting your repos into a Github or Projects folder in your local C drive, like this\n\nC:/Users/yourname/Projects/&lt;your-repo&gt;/\n\nIf you’re cloning many repos you should put the repos into folders separated by the Github org\n\nC:/Users/yourname/Projects/&lt;gh-org-name&gt;/&lt;repo-in-org&gt;/",
    "crumbs": [
      "Github",
      "Policies",
      "Contribution Guide"
    ]
  },
  {
    "objectID": "gh/codespaces.html",
    "href": "gh/codespaces.html",
    "title": "NW-COE Policies",
    "section": "",
    "text": "title: “Github Codespaces” description: How to use Github Codespaces for reproducibility/data democratization date: February 1, 2023 date-modified: today author: Frank Aragona # categories: # - data democratization # - docker # - Github # - reproducibility # —"
  },
  {
    "objectID": "gh/index.html",
    "href": "gh/index.html",
    "title": "Github Policies",
    "section": "",
    "text": "Policies and Rules\nNW-PaGe Github policies\n\nCode Contribution Guide\nRepo Security Rules\nLicensing\nOrganization Requirements\nCode Requirements\n\n\n\n\n\n\nTutorials\nNW-PaGe Github repo tutorials\n\nRelease Cycles\nVirtual Environments\nGithub and Quarto Templates\nGit Basics\nRepo Documentation/Github Pages and Quarto",
    "crumbs": [
      "Github"
    ]
  },
  {
    "objectID": "gh/security.html",
    "href": "gh/security.html",
    "title": "Repo Security",
    "section": "",
    "text": "Objectives\n\nPrevent sensitive information leaks to Github\nSet up guardrails, .gitignore, hooks\nScrub private repos before they go public\nIf sensitive information is leaked and commited to the remote repo, then they will stay in the git history (and will require a lot of effort to remove them from the history). The following cannot be included in any repo or any local commit!:",
    "crumbs": [
      "Github",
      "Policies",
      "Repo Security"
    ]
  },
  {
    "objectID": "gh/security.html#environment-variables-.gitignore",
    "href": "gh/security.html#environment-variables-.gitignore",
    "title": "Repo Security",
    "section": "Environment Variables + .gitignore",
    "text": "Environment Variables + .gitignore\nWe can store private information in local files and make sure that the do not get pushed to the public remote repo by using .gitignore. There are a number of ways to do this. We typically use a yaml file that can be filled out with personal credentials locally. The file will not be committed to the remote repo.\nThere are many ways to achieve this. If you have a more simple workflow that uses R, consider the .Renviron approach. If you have a more complex workflow that has multiple languages and many credentials, consider the yaml approach\n\n.Renvironyaml\n\n\nIf you’re using just R in your repo and have just a few things you want private, consider using a .Renviron file in addition to .gitignore.\n\nIn the .gitignore, add .Renviron:\n\n\n\n\n.gitignore\n\n# R Environment Variables\n.Renviron\n\n\n\nCreate a .Renviron file at the root of you local repo\nAdd the things you want to be kept private\n\n\n\n\n.Renviron\n\nmy_password=\"thisismypassword123\"\n\n\n\nNow in an R script you can call that password and hide the credentials instead of writting the password in the script for everyone to see:\n\n\n\n\n\n\ngood_script.R\n\nmy_password &lt;- Sys.getenv('my_password')\n\n\n\n\n\n\n\nbad_script.R\n\nmy_password &lt;- \"thisismypassword123\"\n\n\n\n\nSys.getenv() looks for the .Renviron file and the variables inside of it. This means you can get all your credentials from the .Renviron but also keep that information\n\n\nHere’s another way to add credentials that may be more robust.\nMany of our scripts use a .yml file that contains a list of API tokens, server names, and usernames/passwords specific to each individual user. There are two .yml files. One is a template (containing no actual passwords..) that exists in the repo and serves as a template so every individual user can keep up to date with new credential additions. The other is the individual creds.yml that is in the repo’s .gitignore. This file will never exist in the repo and only exist locally (in the user’s C drive).\nThe .yml file can work with multiple programming languages including R and Python. They are read in the same way and can be easily adjusted when adding new passwords or using them as configuration files. It can work like this:\n\nIn your .gitignore, add a new line that says creds.yml.\n\n\n\n\n\n.gitignore\n\n# creds files\ncreds.yml\n\n\n\n\nIn the root of you local git clone, make a file called creds.yml.\nIn the yaml file you can nest values. For example, under conn_list_wdrs I have all the parameters needed to make a SQL server connection string in R/Python:\n\n\n\n\ncreds.yml\n\n# Default is needed to distinguish values.\n# Leave a blank line (NO SPACES) as the last line in this file or things will break\n# Quotes aren't necessary, but can be used.\ndefault: \n  conn_list_wdrs:\n    Driver: \"SQL Server Native Client 11.0\"\n    Server: \"someservername\"\n    Database: \"db\"\n    Trusted_connection: \"yes\" \n    ApplicationIntent: \"readonly\"\n    \n  fulgent:\n    username: &lt;USERNAME&gt;\n    password: &lt;PASSWORD&gt;\n\n\n\nTo call these credentials in R or Python it will look like this:\n\n\n\n\n\n\nscript.R\n\nlibrary(yaml)\n\n# read in the local credentials yaml file\ncreds &lt;- yaml::read_yaml(\"creds.yml\")$default\n\n# call in the variables\n\nconnection &lt;- DBI::dbConnect(\n  odbc::odbc(), \n  Driver = creds$conn_list_wdrs$Driver, \n  Server = creds$conn_list_wdrs$Server, \n  Database = creds$conn_list_wdrs$Database, \n  Trusted_connection = creds$conn_list_wdrs$Trusted_connection, \n  ApplicationIntent = creds$conn_list_wdrs$ApplicationIntent\n)\n\n\n\n\n\n\n\nscript.py\n\nimport yaml\n\n# read credentials\nwith open(f\"creds.yml\") as f:\n    creds = yaml.safe_load(f)['default']\n\nconn = pyodbc.connect(\n  DRIVER=creds['conn_list_wdrs']['Driver'],\n  SERVER=creds['conn_list_wdrs']['Server'],\n  DATABASE=creds['conn_list_wdrs']['Database'],\n  Trusted_Connection=creds['conn_list_wdrs']['Trusted_connection'],\n  ApplicationIntent=creds['conn_list_wdrs']['ApplicationIntent']\n  )\n\n\n\n\n\nYou can add more nested sections besides default, like this, where I added a test parameter:\n\n\n\n\ncreds.yml\n\n# Default is needed to distinguish values.\n# Leave a blank line (NO SPACES) as the last line in this file or things will break\n# Quotes aren't necessary, but can be used.\ndefault: \n  conn_list_wdrs:\n    Driver: \"SQL Server Native Client 11.0\"\n    Server: \"someservername\"\n    Database: \"db\"\n    Trusted_connection: \"yes\" \n    ApplicationIntent: \"readonly\"\n    \n  fulgent:\n    username: &lt;USERNAME&gt;\n    password: &lt;PASSWORD&gt;\n\ntest:\n  conn_list_wdrs:\n    Driver: \"SQL Server Native Client 11.0\"\n    Server: \n    Database: \n    Trusted_connection: \n    ApplicationIntent: \n\n\nThis is useful to organized and automatically call different parameters. Now there is a test list with its own variables. This lets us switch a set of variables within our scripts. default applies to the main credentials where test can distinguish which variables should be test or dev scripts specific. Notice below that you can now call the credentials from a .yml file into an R or Python script and the actual credentials will never exist in the code pushed to the repo.\n\n\n\nscript-in-repo.R\n\n# this script is in the repo, but credentials are hidden\nlibrary(yaml)\n\n# read in the local credentials yaml file\ncreds &lt;- yaml::read_yaml(\"path/to/local-credentials.yml\")\n\n# pull in the credentials\nserver_name &lt;- creds$default$conn_list_wdrs$server\n\n\n\nAutomating With Yaml Creds\nWe can even get more specific and add an if-else statement to specify which credential we want to select. This can be helpful if we have a CI/CD pipeline and have a script automatically run on a task scheduler or cron job. We can call the credentials we want in the command line and have the command line code run in my task scheduler. That way we can use multiple different versions of the same script and have all of it be automated.\nFor example,\n\nthe R script on the left uses the commandArgs() to pull any arguments passed to the script in a shell/command line script.\non the right, the shell script has production and test as second arguments.\nthese are passed to the R script as arg[2].\nnow we can use arg[2] in the if-else statement to conditionally select credentials and do it automatically in a pipeline.\n\n\n\n\n\n\nscript-in-repo.R\n\nargs &lt;- commandArgs(TRUE)\n\n# this script is in the repo, but credentials are hidden\nlibrary(yaml)\n\n# read in the local credentials yaml file\ncreds &lt;- yaml::read_yaml(\"path/to/local-credentials.yml\")\n\n# pull in the credentials\nif(args[2] == \"production\"){\n  server_name &lt;- creds$default$conn_list_wdrs$server\n} else if(args[2] == \"test\"){\n  server_name &lt;- creds$test$conn_list_wdrs$server\n}\n\n\n\n\n\n\n\nshell-trigger-script.sh\n\n# Run the production code\n$ Rscript -e \"source('path/script_in_repo.R');\" production\n\n# Run the test/dev code\n$ Rscript -e \"source('path/script_in_repo.R');\" test \n\n\n\n\n\n\nyaml Template\nYou can put a template creds.yml file in your repo so that others can see what credentials they need in order for the code to run.\nThis is a template file, so it will not have any passwords/secrets in it. Its only purpose is to provide an example copy of what a user’s creds.yml file needs to look like.\n\nMake a template called creds_TEMPLATE.yml\nRemove any passwords, usernames, secrets, etc to have it be a file that looks like this:\n\n\n\n\ncreds_TEMPLATE.yml\n\n# Default is needed to distinguish values.\n# Leave a blank line (NO SPACES) as the last line in this file or things will break\n# Quotes aren't necessary, but can be used.\ndefault: \n  conn_list_wdrs:\n    Driver: \n    Server: \n    Database: \n    Trusted_connection: \n    ApplicationIntent: \n    \n  fulgent:\n    username: \n    password: \n\ntest:\n  conn_list_wdrs:\n    Driver: \n    Server: \n    Database: \n    Trusted_connection: \n    ApplicationIntent: \n\n\n\nOnce you have the creds_TEMPLATE.yml template in your repo, make sure that nobody on your team (or anyone with write access..) is able to accidentally push changes to the template. We don’t want someone’s passwords or API tokens to exist in GitHub.\n\nThis link shows how to skip any changes made to the specific file https://stackoverflow.com/a/39776107. If someone makes local changes to the template, the changes will not show in their commit. It is a safe guard.\n\nFor all individual users, run this code:\n\n\n\n\nPowerShell\n\ngit update-index --skip-worktree creds_TEMPLATE.yml\n\n\n\n\nThis will tell your local git to ignore any changes made to creds_TEMPLATE.yml, but also allow it to exist in the repo (since .gitignore will prevent it from being in the repo)\n\nIf you need to update the template file run this:\n\n\n\n\nPowerShell\n\ngit update-index --no-skip-worktree creds_TEMPLATE.yml\n\n\n\n\nThis will allow changes to the template. So when you need to update the template, use this code\nAnd to get a list of files that are “skipped”, use this code:\n\n\n\n\nPowerShell\n\ngit ls-files -v . | grep ^S",
    "crumbs": [
      "Github",
      "Policies",
      "Repo Security"
    ]
  },
  {
    "objectID": "gh/security.html#instructions",
    "href": "gh/security.html#instructions",
    "title": "Repo Security",
    "section": "Instructions",
    "text": "Instructions\n\nCheck that the secrets_key regex is working by running the process on a repo that you know has secrets in it. For example, in a different folder, run all the pre-commit hook steps above and add a known “bad” string into the regex. For example, in the regex put bad_string and in a file in that folder put bad_string. When you scan it should get flagged.\nIf secret scanning is taking too long, you might want to check certain files first. I’ve found that HTML files take a very long time to scan for secrets.\n\nFollow the instructions below to scan for specific files. The script will scan for all the file types that you select. For example, if you want to only scan R files, it will only scan R files.\n\nWindowsWSL/Linux\n\n\n\nIn PowerShell, navigate to your repo and paste this code:\n\n\n\n\nsecret-scanner9000.ps1\n\n# Example Usage\n# write this in the powershell terminal, adjust for the file type(s) you want to scan - can be multiple types: $fileExtensions = @(\".R\", \".py\")\n# then execute this in the terminal: ScanFiles -FileExtensions $fileExtensions\n\n# It will give you an output of any secrets that are contained in those files\n\nFunction ScanFiles{\n  param (\n      [string]$filePath = (Get-Location).Path,\n      [string[]]$fileExtensions\n) \n  Get-ChildItem $filePath -recurse | Where-Object {$_.extension -in $fileExtensions} | \n  Foreach-Object {\n\n      git secrets --scan $_.FullName\n\n  }\n}\n\n\n\nWrite the file extensions you want to scan for in a PowerShell Terminal window like this:\n\n\n\n\nPowerShell\n\n$fileExtensions = @(\".R\",\".py\",\".Rmd\",\".qmd\")\n\n\n\nNow, you can scan your secrets by copying and pasting this code into PowerShell:\n\n\n\n\nPowerShell\n\nScanFiles -FileExtensions $fileExtensions\n\n\n\n\n\nIn a bash/Ubuntu terminal, navigate to your repo and paste this code:\n\n\n\n\nbash\n\nfind . -type f \\( -name \"*.R\" -o -name \"*.py\" -o -name \"*.qmd\" -o -name \"*.rmd\" -o -name \"*.md\" \\) -print0 | xargs -0 -I {} git secrets --scan {}\n\n\n\nThis is set to scan all R, Python, QMD, RMD, or MD files. If you want to add another file type, do it like this where you add -o -name \"*.NEW_TYPE\" to the find command args:\n\n\nfind . -type f \\( -name \"*.R\" -o -name \"*.py\" -o -name \"*.qmd\" -o -name \"*.rmd\" -o -name \"*.md\" -o -name \"*.NEW_TYPE\"  \\) -print0 | xargs -0 -I {} git secrets --scan {}",
    "crumbs": [
      "Github",
      "Policies",
      "Repo Security"
    ]
  },
  {
    "objectID": "gh/git.html",
    "href": "gh/git.html",
    "title": "Git",
    "section": "",
    "text": "Intro\nShowing how to create and work off of a feature branch using git and github.\n\n\nBefore writing code\nFirst check to see if your main branch is up to date and has the most recent commits added. This should be the first thing you do before running/writing any code.\ngit status will tell you:\n\nWhich branch you are in\nIf your local branch is up to date when comparing to that branch in the remote repo\nIf you have any files waiting to be committed\n\ngit fetch will:\n\nRefresh your branch\nSearch for any differences between your local clone and the repo in github. If there are changes, it will display a message\n\ngit pull will pull all the changes in the remote repo into your local clone branch\n \n\ngit status\n\nError in running command C:/Users/FAA3303/new_git/Git/bin/bash.exe\n\n\n \n\ngit fetch\n\nError in running command C:/Users/FAA3303/new_git/Git/bin/bash.exe\n\n\n \n\ngit pull\n\nError in running command C:/Users/FAA3303/new_git/Git/bin/bash.exe\n\n\nIt’s the same in the git desktop app. Make sure you are in the branch you want to be in, then click fetch and pull to update that branch to include the most recent commits in the remote repo\n\n\n\nSwitch to feature branch\nIf we want to make changes to code, first make a new branch off the main.\ngit branch will show all the branches in the repo and the one you are currently in\ngit checkout -b new-branch-name will create a new branch. In this case, we already have our feature branch called test-dcipher-cases\ngit checkout branch-name will switch to a branch. In this case we can switch to test-dcipher-cases\n\ngit branch\n\nError in running command C:/Users/FAA3303/new_git/Git/bin/bash.exe\n\n\n\ngit checkout test-dcipher-cases\n\nOr in the desktop app\n\n\n\nMaking changes\nIf we want to make a change to the code, make a new branch off of test-dcipher-cases and switch to that branch\n\n\ngit checkout -b test-frank2\n\n\nand in the desktop app:\n\n\n\n\nCommitting changes to the feature branch\nNow you can make changes in your R script and when you save them they will be ready to be committed to this new branch.\ngit add to stage your changes\ngit commit -am \"messge\" to commit those changes to the new branch with a message\ngit push --set-upstream origin test-dcipher-cases to push those changes to the remote repo on the new branch\n\ngit add\n\ngit commit -am \"this is a test- pls delete\"\n\ngit push --set-upstream origin test-dcipher-cases\n\n\n\n\n\nMaking a pull request\nThis part happens in github.\n\nSelect who you want to review your code and assign yourself.\nUse labels to tag what this pull request refers to (very helpful in search for changes when managing the project) and\nAdd a milestone if it applies.\n\nThis should automatically send an email to the reviewers that there is code needed to be merged to a branch.\n\n\n\nFor Reviewers\nWhen reviewing changes, make sure the commit/changes are being merged to the correct branch.\nGithub automatically compares to the main branch, so you will have to manually click on the base branch and change it to test-dcipher-cases",
    "crumbs": [
      "Github",
      "Tutorials",
      "Git Basics"
    ]
  },
  {
    "objectID": "tools/templates.html",
    "href": "tools/templates.html",
    "title": "Templates",
    "section": "",
    "text": "This is a Github repo template for R projects. It has renv set up and a .devcontainer for reproducibility\n\n\n\nSelect Use Template &gt; NW-PaGe/R_template when creating a new repo in the NW-PaGe org. The template comes with a pre-filled README.md file that you can edit to your own needs. It’s recommended to leave the .devconainter folder in this repo. It serves as instructions to install all the software and R packages needed to reproduce the repos code using a Github Codespace. See the README.md for more information."
  },
  {
    "objectID": "tools/templates.html#r-github-template",
    "href": "tools/templates.html#r-github-template",
    "title": "Templates",
    "section": "",
    "text": "This is a Github repo template for R projects. It has renv set up and a .devcontainer for reproducibility\n\n\n\nSelect Use Template &gt; NW-PaGe/R_template when creating a new repo in the NW-PaGe org. The template comes with a pre-filled README.md file that you can edit to your own needs. It’s recommended to leave the .devconainter folder in this repo. It serves as instructions to install all the software and R packages needed to reproduce the repos code using a Github Codespace. See the README.md for more information."
  },
  {
    "objectID": "tools/templates.html#purpledoc-quarto-template",
    "href": "tools/templates.html#purpledoc-quarto-template",
    "title": "Templates",
    "section": "Purpledoc Quarto Template",
    "text": "Purpledoc Quarto Template\nThis is a Quarto template that contains the style and images used in this site\n\n\n\nquarto use template coe-test-org/purpledoc\nThis will install the extension and create an example qmd file that you can use as a starting place for your report.\nYou may also use this format with an existing Quarto project or document. From the quarto project or document directory, run the following command to install this format:\nquarto add coe-test-org/purpledoc"
  },
  {
    "objectID": "tools/renv.html",
    "href": "tools/renv.html",
    "title": "Virtual Environments",
    "section": "",
    "text": "Virtual environments allow us to execute code while accounting for software/package version differences we have on our local machines. This repo uses virtual environments to configure a user’s R and Python software and packages to the repo’s specific package versions.\nFor example, say you have dplyr version 2.0 but this repo uses dplyr version 1.1, you may not be able to run the scripts as intended by the author since the functions in dplyr 1.1 may be different than in 2.0. The virtual environment will allow a given user to use only this repo’s version of dplyr so they can run the code as intended.\n\n\n\n\n\n\nImportant\n\n\n\nThere are two different virtual environments for this repo, one for R and another for Python. Your workflows for opening R and Python and how you install packages needs to utilize the virtual environments so that all machines are able to use your code."
  },
  {
    "objectID": "tools/renv.html#step-1-set-up-anaconda",
    "href": "tools/renv.html#step-1-set-up-anaconda",
    "title": "Virtual Environments",
    "section": "Step 1: Set Up Anaconda",
    "text": "Step 1: Set Up Anaconda\nYou should already have Anaconda installed on your machine if not..\nunder construction"
  },
  {
    "objectID": "tools/renv.html#step-2-open-anaconda-prompt",
    "href": "tools/renv.html#step-2-open-anaconda-prompt",
    "title": "Virtual Environments",
    "section": "Step 2: Open Anaconda Prompt",
    "text": "Step 2: Open Anaconda Prompt\nYou may have different Anaconda prompts (prompts aligned with different shells, like PowerShell, bash, etc). There should be a generic Anaconda prompt. Open that one:\n\n\nIf the first line in the prompt doesn’t start with (base), write:\nconda deactivate\nand it will bring you back to your base environment."
  },
  {
    "objectID": "tools/renv.html#step-3-change-directories",
    "href": "tools/renv.html#step-3-change-directories",
    "title": "Virtual Environments",
    "section": "Step 3: Change Directories",
    "text": "Step 3: Change Directories\nChange the directory of the prompt to the repo’s directory. The code is\ncd C:/Users/XXXXXXX/Projects/Sequencing_2.0\nIf you are already in your user directory, you can just type\ncd projects/sequencing_2.0\ncapitalization doesn’t matter\n\n\nNotice that the folder path is now changed to the sequencing repo folder."
  },
  {
    "objectID": "tools/renv.html#step-4-copy-the-repo-env",
    "href": "tools/renv.html#step-4-copy-the-repo-env",
    "title": "Virtual Environments",
    "section": "Step 4: Copy the repo env",
    "text": "Step 4: Copy the repo env\nNow we’re ready to create a new environment based on the repo’s environment.\nType: conda env create --name seq_env --file=environment.yml\nNote that how you name your environment doesn’t really matter, but name it something that resembles the repo. This will save the headache of having random environments for random repos that you can’t remember..\n\n\nconda env create will create a new environment in your C:/Users/XXXXX/Anaconda3/envs file path\n--name or -n will name that environment, in this case seq_env\n--file=environment.yml this code will take the file in the sequencing 2.0 repo and use it to create this environment. It is essentially a copy of the software versions in the file.\n\nNote: I sped up the gif below. The whole process may take a few minutes"
  },
  {
    "objectID": "tools/renv.html#step-5-activate-the-environment",
    "href": "tools/renv.html#step-5-activate-the-environment",
    "title": "Virtual Environments",
    "section": "Step 5: Activate the environment",
    "text": "Step 5: Activate the environment\nYou can switch between environments in the conda prompt or in a programming IDE (or both? idk). To activate and switch the env, write:\nconda activate &lt;env_name&gt;\nin this case\nconda activate seq_env\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe environment your in will show on the left of the prompt message. In this case it says (seq_env) instead of (base). That way you know what env your working in"
  },
  {
    "objectID": "tools/renv.html#ide-setup---vs-code",
    "href": "tools/renv.html#ide-setup---vs-code",
    "title": "Virtual Environments",
    "section": "IDE Setup - VS Code",
    "text": "IDE Setup - VS Code\nVS Code has a lot built in to use a conda environment. Since your env is already activated, if you have VS Code installed, you can type\ncode\ninto the anaconda prompt and it will open a VS Code window\n\n\nStep 1: Select a Python Interpreter\nFirst we need to select a python interpreter, which is in our env. On your keyboard, press\nCTRL+SHIFT+P\nThis should bring up a window with an option that says Python: Select Interpreter. You may need to search for it.\nClick it and you should see your new environment seq_env in the list. Click it\n\n\n\nStep 2: Write code\nNow your VS Code is using your environment and the python version/packages in that environment. Check to see that your terminal is using the correct env.\nOpen the terminal (terminal &gt; new terminal) and confirm that you are in a cmd prompt in the terminal. On the right side of the terminal it should say cmd. If it says powershell or something else, let’s change it.. See the pic below. There’s a drop down that gives you shell types. Change your default to Command Prompt\n\n\nAlso notice in the picture that my environment now switches to seq_env. Yours should do the same. You should now be able to run code in a python script. Notice that your terminal will change to run python. If you get an error, write python in the terminal and hit enter. It will change your terminal a little. Now you can run python code and it will output to this terminal."
  },
  {
    "objectID": "tools/renv.html#ide-setup---pycharm",
    "href": "tools/renv.html#ide-setup---pycharm",
    "title": "Virtual Environments",
    "section": "IDE Setup - PyCharm",
    "text": "IDE Setup - PyCharm\nPyCharm also works great with a conda environment.\n\nStep 1: Select a Python Interpreter\nYou may also be able to open a PyCharm window from an Anaconda prompt like with VS Code (if it’s installed in your env). To do so, write pycharm in the prompt and it should open a new window with the env activated.\nIf that doesn’t work, open PyCharm and on the bottom right there is a python version and interpreter selected. Click it and open “Add New Interpreter” &gt; “Add local interpreter”. This opens a new window. Click “Conda Environment” and under “Interpreter” click the dropdown. You should be able to see your new environment there. If not, click away and click the dropdown again. It’s weird sometimes.\nThen click okay. Close and reopen the Python Console window and it should have your environment path for the python.exe. Also, the Python Libraries window should have all of the libraries in your environment now.\n\n\nNotice that now there are a list of interpreters for you to use. You can now switch back and forth between environments. This is great if you have other repos to use or want to test out new packages that aren’t in the main environment."
  },
  {
    "objectID": "tools/renv.html#step-1-install-a-new-package",
    "href": "tools/renv.html#step-1-install-a-new-package",
    "title": "Virtual Environments",
    "section": "Step 1: Install a new package",
    "text": "Step 1: Install a new package\nGo to the Anaconda prompt, make sure you’re in the repo file path (cd projects/sequencing_2.0) and make sure you’re in the right conda env (conda activate seq_env).\nNow, install the package. Usually packages can be installed with pip install or conda install or conda install -c conda forge &lt;package&gt;. This depends on the packages. Some need pip, others need conda. Google it to find out. Here i’m going to download a package from NCBI to demonstrate. The package is called ncbi-datasets-cli.\n\nThis package uses conda-forge to install. Type in conda install -c conda-forge ncbi-datasets-cli\nIt will give you a message Y/N to confirm. Type “y” and enter"
  },
  {
    "objectID": "tools/renv.html#step-2-save-the-package-to-the-repo",
    "href": "tools/renv.html#step-2-save-the-package-to-the-repo",
    "title": "Virtual Environments",
    "section": "Step 2: Save the package to the repo",
    "text": "Step 2: Save the package to the repo\nNow we need to save this package to the repo’s environment.yml\n\nType conda env export &gt; environment.yml\nSince the package is in your environment, this code is exporting your new environment to repo’s one.\nNow push to github"
  },
  {
    "objectID": "tools/renv.html#creating-renv-in-a-project",
    "href": "tools/renv.html#creating-renv-in-a-project",
    "title": "Virtual Environments",
    "section": "Creating renv in a project",
    "text": "Creating renv in a project\n\nStep 1: Open the .Rproj in your repo\nThe R project will open up Rstudio at the root of you directory path.\n\n\n\nStep 2: Initialize renv for the repo\nNow that we’re in the root of your repo directory, let’s initialize renv.\nFirst install renv - install.packages(\"renv\")\nThen in your console write renv::init() and run it.\n\nIf you already have an existing repo, you will probably see warnings and errors in the renv::init like I did in the gif above. Not to worry! Read the warnings and follow the instructions. Usually you will need to re-install a package. If you get this warning:\nThese may be left over from a prior, failed installation attempt.\nConsider removing or reinstalling these packages.\n\nThen run renv::install(\"THAT PACKAGE\"). It will install the package again,\nand then you need to update the lock file (more on that later) by running renv::snapshot().\n\nNow the package will be installed correctly\n\nrenv::init() will:\n\nSearch through all R scripts in your repo and find all packages used\nCreate a snapshot of those packages\nSave all packages in the repo in a new renv libraries path (similar to your C drive R libraries paths)\nCreate a .gitignore within the renv libraries path so that you don’t get spammed with thousands of libraries in your git commit\nCreate a lock file - this is like the environment.yml for conda. Think of it as instructions for which packages your repo is using\nIt also saved things like an activate R script which will activate that renv every time the repo is opened from the .Rproj\n\n\n\nStep 3: Push to Github\nNow look at your git stage and you will see all the files renv created.\nWe have\n\n.Rprofile that contains an renv activate.R script - this will activate the repo’s renv every time the project is opened\nThe renv.lock file shows information on each package used in the repo and is used to update collaborator’s environments to match the lock file.\nrenv/.gitignore I don’t feel like explaining this one right now - i’ll write more later\nrenv/activate.R this will activate the env whenever the R project is opened\nrenv/settings.dcf I have no clue what this is"
  },
  {
    "objectID": "tools/renv.html#using-renv-in-a-project",
    "href": "tools/renv.html#using-renv-in-a-project",
    "title": "Virtual Environments",
    "section": "Using renv in a project",
    "text": "Using renv in a project\n\nStep 1: Open the .Rproj for your repo\nAny time you need to code or run code from the repo, open up the .Rproj file that contains the sequencing 2.0 project. In your file explorer, go to the repo and open Sequencing_2.0 .Rproj\n\nThis will open up an R window with the repo file path as a root directory. It will also utilize the renv. Your console should say something about renv, like this\n\n\n\nStep 2: Load renv packages\nThe first time you use renv you will need to configure it to your local machine. To do this, type:\n\nrenv::restore() in your console.\nThis will create a new environment for your R in your local machine using the lock file packages.\n\n\nNow you’re ready to use the scripts! Way less complicated than conda"
  },
  {
    "objectID": "tools/index.html",
    "href": "tools/index.html",
    "title": "Guides and Templates",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\nDate\n\n\nTitle\n\n\nAuthor\n\n\nReading Time\n\n\n\n\n\n\n\n\n\nSep 1, 2023\n\n\nCode and Repo Documentation\n\n\nFrank Aragona\n\n\n13 min\n\n\n\n\n\n\n\nFeb 1, 2023\n\n\nGit\n\n\nFrank Aragona\n\n\n3 min\n\n\n\n\n\n\n\nMay 21, 2024\n\n\nLink external R code to the documentation\n\n\nFrank Aragona\n\n\n1 min\n\n\n\n\n\n\n\nSep 1, 2023\n\n\nPackage Documentation\n\n\nFrank Aragona\n\n\n1 min\n\n\n\n\n\n\n\nSep 1, 2023\n\n\nRelease Cycles\n\n\nFrank Aragona\n\n\n6 min\n\n\n\n\n\n\n\nSep 1, 2023\n\n\nTemplates\n\n\nFrank Aragona\n\n\n1 min\n\n\n\n\n\n\n\nFeb 1, 2023\n\n\nVirtual Environments\n\n\nFrank Aragona\n\n\n11 min\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "tools/git.html",
    "href": "tools/git.html",
    "title": "Git",
    "section": "",
    "text": "Intro\nShowing how to create and work off of a feature branch using git and github.\n\n\nBefore writing code\nFirst check to see if your main branch is up to date and has the most recent commits added. This should be the first thing you do before running/writing any code.\ngit status will tell you:\n\nWhich branch you are in\nIf your local branch is up to date when comparing to that branch in the remote repo\nIf you have any files waiting to be committed\n\ngit fetch will:\n\nRefresh your branch\nSearch for any differences between your local clone and the repo in github. If there are changes, it will display a message\n\ngit pull will pull all the changes in the remote repo into your local clone branch\n \n\ngit status\n\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges to be committed:\n  (use \"git restore --staged &lt;file&gt;...\" to unstage)\n    new file:   images/gitdesk.gif\n    new file:   images/gitdesk23-01.gif\n    new file:   images/gitdesk23.gif\n    new file:   images/gitdesk233-01.gif\n    new file:   images/gitdesk233.gif\n    new file:   images/gitdesk2333-01.gif\n    new file:   images/gitdesk2333.gif\n\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n    modified:   git.qmd\n\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n    ../nul\n    git.rmarkdown\n\n\n \n\ngit fetch\n\n \n\ngit pull\n\nAlready up to date.\n\n\nIt’s the same in the git desktop app. Make sure you are in the branch you want to be in, then click fetch and pull to update that branch to include the most recent commits in the remote repo\n\n\n\nSwitch to feature branch\nIf we want to make changes to code, first make a new branch off the main.\ngit branch will show all the branches in the repo and the one you are currently in\ngit checkout -b new-branch-name will create a new branch. In this case, we already have our feature branch called test-dcipher-cases\ngit checkout branch-name will switch to a branch. In this case we can switch to test-dcipher-cases\n\ngit branch\n\n  listings\n* main\n\n\n\ngit checkout test-dcipher-cases\n\nOr in the desktop app\n\n\n\nMaking changes\nIf we want to make a change to the code, make a new branch off of test-dcipher-cases and switch to that branch\n\n\ngit checkout -b test-frank2\n\n\nand in the desktop app:\n\n\n\n\nCommitting changes to the feature branch\nNow you can make changes in your R script and when you save them they will be ready to be committed to this new branch.\ngit add to stage your changes\ngit commit -am \"messge\" to commit those changes to the new branch with a message\ngit push --set-upstream origin test-dcipher-cases to push those changes to the remote repo on the new branch\n\ngit add\n\ngit commit -am \"this is a test- pls delete\"\n\ngit push --set-upstream origin test-dcipher-cases\n\n\n\n\n\nMaking a pull request\nThis part happens in github.\n\nSelect who you want to review your code and assign yourself.\nUse labels to tag what this pull request refers to (very helpful in search for changes when managing the project) and\nAdd a milestone if it applies.\n\nThis should automatically send an email to the reviewers that there is code needed to be merged to a branch.\n\n\n\nFor Reviewers\nWhen reviewing changes, make sure the commit/changes are being merged to the correct branch.\nGithub automatically compares to the main branch, so you will have to manually click on the base branch and change it to test-dcipher-cases"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This site was made with Quarto. It can execute code and render the outputs into the html."
  },
  {
    "objectID": "tools/link_code.html",
    "href": "tools/link_code.html",
    "title": "Link external R code to the documentation",
    "section": "",
    "text": "The code in this website is automatically linked to the code in the repository. This lets us update the code and not need to copy and paste any new changes to the documentation/github page\nTo do this, open your external R script in your repo. In this case we’re using lineages_public_repo.R. Now wrap the chunks of code you want to link with comments like this, ## ---- libraries and ## ---- stop:\n\n\n\n## ---- libraries\nlibrary(pacman)\np_load(\n  reticulate,\n  fs,\n  lubridate,\n  dplyr,\n  stringr,\n  magrittr,\n  readr,\n  httr\n)\n## ---- stop\n\n\n\nThe ## ---- libraries signals the beginning of a chunk. the ## ---- stop signals the end of a chunk.\n\nNow you can call this chunk in your github page/quarto document like this:\nScan the external R script for code chunks:\n\n```{r setup}\n#| echo: false\nknitr::read_chunk(file.path(getwd(),\"lineages_public_repo.R\"))\n```\n\n\nCall the code chunk you want in the {r} header within the chunk. like this {r libraries}:\n\n```{r libraries}\n\n```\n\n\nAnd now the document will output any code in that code chunk and can also execute that code chunk if you want. Here’s what the output will look like in this case:"
  },
  {
    "objectID": "tools/release.html",
    "href": "tools/release.html",
    "title": "Release Cycles",
    "section": "",
    "text": "Summary\n\nGithub Releases\nHelps devs and end users\nChangelogs and semantic versioning\nAutomate the release process"
  },
  {
    "objectID": "tools/release.html#github-action-for-auto-releases",
    "href": "tools/release.html#github-action-for-auto-releases",
    "title": "Release Cycles",
    "section": "Github Action for auto releases",
    "text": "Github Action for auto releases\nI recommend first creating a test repo for this. In the repo, create a Github Action workflow called changelog.yml. You can copy the full file below:\n\n\n\n\n.github/workflows/changelog.yml\n\nname: Changelog\non:\n  push:\n    branches:\n      - main\n\njobs:\n  changelog:\n    runs-on: ubuntu-latest\n    \n    permissions:\n      # write permission is required to create a github release\n      contents: write\n\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Conventional Changelog Action\n        id: changelog\n        uses: TriPSs/conventional-changelog-action@v3\n        with:\n          github-token: ${{ secrets.github_token }}\n          create-summary: true\n\n      - name: Create Release\n        uses: actions/create-release@v1\n        if: ${{ steps.changelog.outputs.skipped == 'false' }}\n        env:\n          GITHUB_TOKEN: ${{ secrets.github_token }}\n        with:\n          prerelease: false\n          tag_name: ${{ steps.changelog.outputs.tag }}\n          release_name: ${{ steps.changelog.outputs.tag }}\n          body: ${{ steps.changelog.outputs.clean_changelog }}"
  },
  {
    "objectID": "tools/how_to.html",
    "href": "tools/how_to.html",
    "title": "Code and Repo Documentation",
    "section": "",
    "text": "This site was created using Quarto, Github, and uses a Github Action to automatically render when a commit is pushed to the main branch of this repository.\nQuarto is a framework for creating documentation, slideshows, articles, blogs, books and websites using markdown. It can execute R, Python and other programming languages within the document.\nGithub Actions uses a .yml file in the repository to trigger an action based on a certain event. In this case, when a commit is pushed to the main branch the .yml will trigger this Quarto website to render to the gh-pages branch of the repository and publish the github page. This section will give details on how to\n\nCreate the website\nCreate, edit, and troubleshoot the Github Action to render the site"
  },
  {
    "objectID": "tools/how_to.html#editadd-sections-and-chapters",
    "href": "tools/how_to.html#editadd-sections-and-chapters",
    "title": "Code and Repo Documentation",
    "section": "Edit/Add Sections and Chapters",
    "text": "Edit/Add Sections and Chapters\nTo add a section, open up the _quarto.yml file and scroll to the navbar section\n\n\n\n\n_quarto.yml\n\nproject:\n  type: website\nwebsite:\n  title: \"COE Github Standards\"\n  search: true\n  \n  navbar: \n    background: primary\n    left: \n      - text: Home\n        href: index.qmd\n      - text: Github Organization Standards\n        menu: \n          - href: std/security.qmd\n            text: \"0: Security Standards\"\n          - href: std/lic.qmd\n            text: \"1: Choosing a License\"\n          - href: std/templates.qmd\n            text: \"2: Org Policy Setting\"\n\n\n\n\nThis is where all of the qmd files are sourced and the instructions on how to format and style the navigation bar in the website.\nCurrently, the project is set up to have each section have it’s own drop down menu in the navbar. In a section, use - href: to specify a file and text: to give the file a custom name in the website.\nEach chapter exists within a sub-folder, so to add a chapter make sure create the qmd in its sub-folder and then reference the sub-folder and chapter in the .yml. For example, if you make a new chapter called new-chapter.qmd and it exists in the covid section/sub-folder, you need to reference it in the .yml file like: covid/new-chapter.qmd"
  },
  {
    "objectID": "tools/how_to.html#website-style",
    "href": "tools/how_to.html#website-style",
    "title": "Code and Repo Documentation",
    "section": "Website Style",
    "text": "Website Style\nYou can customize many aspects of the website in the .yml file itself with the format: function. There are a ton of themes included in Quarto here and you can also add a custom css and/or scss file to your project. I think you can even go super in depth and customize the javascript components of the site, but I’m not entirely sure how to do that yet. This website has a ton of custom css components with Quarto, and possibly uses custom javascript, so it could be a place to start if you’re interested. Basically, you need to embed the css file into your _quarto.yml file\n\n\n\n\n_quarto.yml\n\nformat:\n  html:\n    theme: \n      - cosmo\n      - assets/styles.scss\n    scss: assets/styles.scss\n    # css: styles.css\n    toc: true\n    highlight-style: assets/custom.theme"
  },
  {
    "objectID": "tools/how_to.html#open-the-r-project",
    "href": "tools/how_to.html#open-the-r-project",
    "title": "Code and Repo Documentation",
    "section": "Open the R project",
    "text": "Open the R project\nThis is a Quarto website that is contained in a .rproj file path. The R project contains all the documents used to create this website. Begin by opening the R project when should be in your local clone under C:\\Users\\XXXXXXX\\Projects\\Sequencing_2.0\\sequencing_documentation\\sequencing_documentation.Rproj"
  },
  {
    "objectID": "tools/how_to.html#open-the-files",
    "href": "tools/how_to.html#open-the-files",
    "title": "Code and Repo Documentation",
    "section": "Open the files",
    "text": "Open the files\nThis project has .qmd files (Quarto Markdown files) that each represent a chapter in the website. All of the .qmd files are knitted together (using R knitr) which compiles all of the files to be sourced into htmls.\nThis website is set up to have each major section contain multiple chapters. To open a chapter, the bottom right pane in your R Studio window should contain folders for each section, highlighted below\n\n\n$ tree /f\nC:.\n│   .gitignore\n│   about.qmd\n│   index.qmd\n│   standards.Rproj\n│   _quarto.yml\n│\n├───assets\n│       custom.theme\n│       styles.css\n│       styles.scss\n│\n├───std\n│   │   creds.qmd\n│   │   lic.qmd\n│   │   public_code.qmd\n│   │   security.qmd\n│   │   templates.qmd\n│   │\n│   └───images\n│\n├───tools\n│   │   how_to.qmd\n│   │   iac.qmd\n│   │   link_code.qmd\n│   │   readme.qmd\n│   │   release.qmd\n│   │   renv.qmd\n│   │   teams.qmd\n│   │\n│   └───images\n\nError in running command bash\n\n\n\n\nThe .qmd files are inside of these folders. Select one to edit."
  },
  {
    "objectID": "tools/how_to.html#commit-changes",
    "href": "tools/how_to.html#commit-changes",
    "title": "Code and Repo Documentation",
    "section": "Commit changes",
    "text": "Commit changes\nOnce you’re done editing, push the change to the main branch (or make a new branch, and then a pull request for the main branch). More one this in the git chapter"
  },
  {
    "objectID": "tools/how_to.html#example-yaml-workflow",
    "href": "tools/how_to.html#example-yaml-workflow",
    "title": "Code and Repo Documentation",
    "section": "Example YAML Workflow",
    "text": "Example YAML Workflow\nThe .yml workflow for this project looks something like this:\non: is a tag indicating when the action will run. Right now it will run when any code gets pushed to the main branch in the documentation folder or lineages_public_repo.R script\n\n\n\n\nquarto-publish.yml\n\non: \n  push:\n    branches:\n      - main\n    paths:\n      - documentation/**\n      - lineages_public_repo.R\n\n\n\njobs: is a tag that tells a Github virtual machine what to run and what operating system to run it on. In this case ubuntu with the latest version. This can be windows, linux or macOS.\n\n\n\n\nquarto-publish.yml\n\nname: Render and Publish\n\njobs:\n  build-deploy:\n    runs-on: ubuntu-latest\n\n\n\n\nNow we have the steps:\n\nenv will find the renv folder\nuses: actions/checkout@v3 will refresh the repo and pull the latest changes\nuses: quarto-dev/quarto-actions/setup@v2 will install quarto\nuses: actions/cache@v1 and the code below it will set up renv and use the cached packages to install them onto the Github virtual machine\n\n\n\n\n\nquarto-publish.yml\n\n    env:\n      RENV_PATHS_ROOT: ~/.cache/R/renv\n      \n    steps:\n      - name: Check out repository\n        uses: actions/checkout@v3\n        \n      - name: Set up Quarto\n        uses: quarto-dev/quarto-actions/setup@v2\n        \n      - name: Prep CURL install\n        run: sudo apt-get update\n\n      - name: Install CURL Headers\n        run: sudo apt-get install libcurl4-openssl-dev\n\n      # - name: Setup Renv\n      #   uses: r-lib/actions/setup-renv@v2\n  \n      - name: Cache packages\n        uses: actions/cache@v1\n        with:\n          path: ${{ env.RENV_PATHS_ROOT }}\n          key: ${{ runner.os }}-renv-${{ hashFiles('**/renv.lock') }}\n          restore-keys: |\n            ${{ runner.os }}-renv-\n      \n      - name: Restore packages\n        shell: Rscript {0}\n        run: |\n          if (!requireNamespace(\"renv\", quietly = TRUE)) install.packages(\"renv\")\n          renv::restore()\n\n\n\n\nAnd finally,\n\nuses: quarto-dev/quarto-actions/publish@v2 will render the site by running quarto render\nwith: target: gh-pages path: documentation/_site lets you know which branch and path to render the site to\n\n\n\n\n\nquarto-publish.yml\n\n      - name: Publish to GitHub Pages (and render)\n        uses: quarto-dev/quarto-actions/publish@v2\n        with:\n          target: gh-pages\n          path: documentation/_site\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # this secret is always available for github actions"
  },
  {
    "objectID": "tools/how_to.html#using-renv-in-the-gh-action",
    "href": "tools/how_to.html#using-renv-in-the-gh-action",
    "title": "Code and Repo Documentation",
    "section": "Using renv in the GH Action",
    "text": "Using renv in the GH Action\nIf you need to constantly update your website with code chunk, this is the best way to do it. It is also probably safer and better than the _freeze way, but it requires a better understanding of Github Actions and virtual environments.\nrenv is an R package for creating a project level virtual environment. In other words, renv will create project specific folders that contain the specific R package versions you use in an project. More on this here\nTo use renv in a Github Action, you can put\n\n\n\n\nquarto-publish.yml\n\n- name: Setup Renv\n  uses: r-lib/actions/setup-renv@v2\n\n\n\nor use the renv cache code in the yaml section above"
  },
  {
    "objectID": "tools/how_to.html#using-a-_freeze-file",
    "href": "tools/how_to.html#using-a-_freeze-file",
    "title": "Code and Repo Documentation",
    "section": "Using a _freeze file",
    "text": "Using a _freeze file\nIf you only need to execute the code once or just need to render a non-executable code chunk once, make sure you have this code in your _quarto.yml file:\n\n\n\n\n_quarto.yml\n\nexecute:\n  error: true\n  freeze: true\n\n\n\nand then run this in your terminal window:\nquarto render name-of-specific-document-or-chapter.qmd\nThis will render that specific document in the website, execute code chunks if they are set to execute (eval: true) and then it will create a _freeze file. The _freeze file will save a snapshot of that specific document and not re-render it in the Github Action. This means you can render other parts of the website, but any files in the _freeze folder will stay the same as they are in the freeze. If you need to make changes to a freeze document, run the quarto render code again after making changes.\nThis is also documented in the Quarto dev documentation"
  },
  {
    "objectID": "tools/how_to.html#troubleshooting",
    "href": "tools/how_to.html#troubleshooting",
    "title": "Code and Repo Documentation",
    "section": "Troubleshooting",
    "text": "Troubleshooting\nSo you did these steps:\n\nCreate the quarto-publish.yml\nRun quarto publish gh-pages in the terminal\nPush all the files in your git to the main branch\n\nIf this works on your first try then the universe is taking extra special care of you.\nIf not, you are like the rest of us poor souls:/\n\nThe first thing I would check is the error in your Github repo’s Action tab.\nIf the error is something like jsonlite not installed or some package not installed then it most likely means your are trying to commit a chunk of code in the documentation. Even if you are not executing the code, Github Actions will punish you. There are a couple options to fix this, depending on your priorities.\n\nIf you don’t care about executing your code and/or only need to push that part of the script once, consider using the _freeze option\nIf you need to execute code or need to programmtically render the document with code chunks often, consider using renv or a similar package installation method"
  },
  {
    "objectID": "gh/policies.html",
    "href": "gh/policies.html",
    "title": "Org Policies",
    "section": "",
    "text": "Objectives\n\nEnsure that all repos in the org have the required documents\nSet policy rules at the Organization level\nRepos need to have reproducible code\nRepos need to have documentation\nIn the Github Organization we may require all repositories to contain certain documents. For example, we want to make sure that every repo has a CODE OF CONDUCT document that is a general policy applied throughout the organization.\nHere’s a list of required documents:",
    "crumbs": [
      "Github",
      "Policies",
      "Org Policies"
    ]
  },
  {
    "objectID": "gh/policies.html#readme",
    "href": "gh/policies.html#readme",
    "title": "Org Policies",
    "section": "README",
    "text": "README\nREADME files are instructions or documentation on how to use your software. It should give a quick introduction to the repo and instructions on how to install or run the code.",
    "crumbs": [
      "Github",
      "Policies",
      "Org Policies"
    ]
  },
  {
    "objectID": "gh/policies.html#code_of_conduct",
    "href": "gh/policies.html#code_of_conduct",
    "title": "Org Policies",
    "section": "CODE_OF_CONDUCT",
    "text": "CODE_OF_CONDUCT\nA Code of Conduct can let a user know what the rules of the organization are and how any wrongful behavior will be addressed. The document will provide the “standards for how to engage in a community”",
    "crumbs": [
      "Github",
      "Policies",
      "Org Policies"
    ]
  },
  {
    "objectID": "gh/policies.html#contributing.md",
    "href": "gh/policies.html#contributing.md",
    "title": "Org Policies",
    "section": "CONTRIBUTING.md",
    "text": "CONTRIBUTING.md\nThis file should appear in the issue tab in a repo. It lets a user know how they can contribute to the project and if they need to sign any forms before contributing. Some larger organizations require that a person knows what they are contributing to and they must sign a form acknowledging that any software/code contributions to the project will be used and cannot be retracted by the user. The code submitted may also be used to develop processes but the organization will not pay the individual contributor (since this is open-source, we only look for open-source contributions)",
    "crumbs": [
      "Github",
      "Policies",
      "Org Policies"
    ]
  },
  {
    "objectID": "gh/policies.html#license",
    "href": "gh/policies.html#license",
    "title": "Org Policies",
    "section": "LICENSE",
    "text": "LICENSE\nThese should be and are set at the repo level. There will be many different licenses to choose from that will depend on the specific repo. More on that here.",
    "crumbs": [
      "Github",
      "Policies",
      "Org Policies"
    ]
  },
  {
    "objectID": "gh/policies.html#document-requirements-with-.github-repos",
    "href": "gh/policies.html#document-requirements-with-.github-repos",
    "title": "Org Policies",
    "section": "Document Requirements with .github Repos",
    "text": "Document Requirements with .github Repos\nYou can set most policy rules and create documents for each repo at the organization level by using a special .github repo. Dot files and dot folders have special functionality in some software. For Github, the .github folder defines workflows for things like Github Actions in a repo. A .github repository on the other hand defines organization level rules and templates.\n\nIn order to write and set these policies at the organization level we can put them at the root of the .github repository and edit them there.\n\n\n\n\nPowerShell\n\n$ tree /f\nC:.\n│   .gitignore\n│   CODE_OF_CONDUCT.md\n│   CONTRIBUTING.md\n│   LICENSE\n│   README.md\n│\n├───.github\n└───profile\n        README.md\n\n\n\nTake a look above. I have the required documents/policies at the root of the .github repo directory. Now if I open up any given repo in the organization I will find a link to those files:\n\nIf you click on the CODE_OF_CONDUCT link it will take you right to the .github repo and open the CODE_OF_CONDUCT.md file there:\n\nNow you can set organization level policies from the .github repo and they will automatically populate in all existing and new repositories unless there are repo specific policies in place. If a repo already has its own policies they will not be overwritten.",
    "crumbs": [
      "Github",
      "Policies",
      "Org Policies"
    ]
  },
  {
    "objectID": "gh/policies.html#commit-sign-off-requirement---github-apps",
    "href": "gh/policies.html#commit-sign-off-requirement---github-apps",
    "title": "Org Policies",
    "section": "Commit Sign-Off Requirement - Github Apps",
    "text": "Commit Sign-Off Requirement - Github Apps\nWe may want to require authors or reviewers to sign-off on commits to a repo. This is sometimes established in projects to “ensure that copyrighted code not released under an appropriate free software (open source) license is not included in the kernel.”\nYou can install a Github App in the organization and it will be applied to all repos. The DCO App (Developer Certificate of Origin) is popular and lightweight. To install it in the organization, click on Configure and it will give you the option to configure it with the organization of choice.",
    "crumbs": [
      "Github",
      "Policies",
      "Org Policies"
    ]
  },
  {
    "objectID": "gh/reproduce.html",
    "href": "gh/reproduce.html",
    "title": "Reproducibility",
    "section": "",
    "text": "Objectives\n\nData and Code Democratization\nGithub Codespaces\nPackage reproducibility with virtual environments\nGithub Releases\nDocumentation",
    "crumbs": [
      "Github",
      "Policies",
      "Reproducibility"
    ]
  },
  {
    "objectID": "gh/reproduce.html#open-a-codespace",
    "href": "gh/reproduce.html#open-a-codespace",
    "title": "Reproducibility",
    "section": "2.1 Open a Codespace",
    "text": "2.1 Open a Codespace\nAt the root of the repo, click on the Code drop down button\n\nOn the right there is a tab called Codespaces.\nClick the + sign and a Codespace will launch\n\n\n\n\nopen up a codespace\n\n\nThis will open up a VS Code window in your browser. There are also options to open up a Jupyter Notebook or Jetbrains IDE (Pycharm). You can also install an Rstudio IDE into the codespace. It will look something like this - note that the repository is already linked and checked out into the codespace:\n\n\n\nVS Code IDE in Github Codespaces\n\n\nHere you can install most software. You can also customize the Codespace so that whenever someone opens one in your repo it will come with software pre-installed. More on that in the devcontainers section",
    "crumbs": [
      "Github",
      "Policies",
      "Reproducibility"
    ]
  },
  {
    "objectID": "gh/reproduce.html#devcontainers",
    "href": "gh/reproduce.html#devcontainers",
    "title": "Reproducibility",
    "section": "2.2 Devcontainers",
    "text": "2.2 Devcontainers\nDevcontainers are a way to install software into a Codespace so that whenever a user opens up the Codespace they won’t need to install anything themselves. Making a container can be a little tricky, so we’ve made Github templates that have devcontainers already made. See templates. There are R, Python, and general default templates. These containers will install R, Rstudio, Python, and all the packages in the repo’s virtual environments (venv, conda, pip, renv, etc) so that the user can run all the code in your repo within a couple minutes.\nTo set up a devcontainer for yourself;\n\nClick on `Code &gt; Codespaces &gt; Configure dev container\n\n\n\nThis will make a folder named .devcontainer at the root of your repo\nIn that folder it will make a file named devcontainer.json\nOn the right there is a searchable marketplace for software to add to your container\n\n\n\nEach one comes with instructions on how to add the software to the .devcontainer.json\n\nFor more information about Codespaces, see the guides here",
    "crumbs": [
      "Github",
      "Policies",
      "Reproducibility"
    ]
  },
  {
    "objectID": "gh/link_code.html",
    "href": "gh/link_code.html",
    "title": "Link external R code to the documentation",
    "section": "",
    "text": "The code in this website is automatically linked to the code in the repository. This lets us update the code and not need to copy and paste any new changes to the documentation/github page\nTo do this, open your external R script in your repo. In this case we’re using lineages_public_repo.R. Now wrap the chunks of code you want to link with comments like this, ## ---- libraries and ## ---- stop:\n\n\n\n## ---- libraries\nlibrary(pacman)\np_load(\n  reticulate,\n  fs,\n  lubridate,\n  dplyr,\n  stringr,\n  magrittr,\n  readr,\n  httr\n)\n## ---- stop\n\n\n\nThe ## ---- libraries signals the beginning of a chunk. the ## ---- stop signals the end of a chunk.\n\nNow you can call this chunk in your github page/quarto document like this:\nScan the external R script for code chunks:\n\n```{r setup}\n#| echo: false\nknitr::read_chunk(file.path(getwd(),\"lineages_public_repo.R\"))\n```\n\n\nCall the code chunk you want in the {r} header within the chunk. like this {r libraries}:\n\n```{r libraries}\n\n```\n\n\nAnd now the document will output any code in that code chunk and can also execute that code chunk if you want. Here’s what the output will look like in this case:"
  },
  {
    "objectID": "gh/renv.html",
    "href": "gh/renv.html",
    "title": "Virtual Environments",
    "section": "",
    "text": "Virtual environments allow us to execute code while accounting for software/package version differences we have on our local machines. This repo uses virtual environments to configure a user’s R and Python software and packages to the repo’s specific package versions.\nFor example, say you have dplyr version 2.0 but this repo uses dplyr version 1.1, you may not be able to run the scripts as intended by the author since the functions in dplyr 1.1 may be different than in 2.0. The virtual environment will allow a given user to use only this repo’s version of dplyr so they can run the code as intended.\n\n\n\n\n\n\nImportant\n\n\n\nThere are two different virtual environments for this repo, one for R and another for Python. Your workflows for opening R and Python and how you install packages needs to utilize the virtual environments so that all machines are able to use your code.",
    "crumbs": [
      "Github",
      "Tutorials",
      "Virtual Environments"
    ]
  },
  {
    "objectID": "gh/renv.html#step-1-set-up-anaconda",
    "href": "gh/renv.html#step-1-set-up-anaconda",
    "title": "Virtual Environments",
    "section": "Step 1: Set Up Anaconda",
    "text": "Step 1: Set Up Anaconda\nYou should already have Anaconda installed on your machine if not..\nunder construction",
    "crumbs": [
      "Github",
      "Tutorials",
      "Virtual Environments"
    ]
  },
  {
    "objectID": "gh/renv.html#step-2-open-anaconda-prompt",
    "href": "gh/renv.html#step-2-open-anaconda-prompt",
    "title": "Virtual Environments",
    "section": "Step 2: Open Anaconda Prompt",
    "text": "Step 2: Open Anaconda Prompt\nYou may have different Anaconda prompts (prompts aligned with different shells, like PowerShell, bash, etc). There should be a generic Anaconda prompt. Open that one:\n\n\nIf the first line in the prompt doesn’t start with (base), write:\nconda deactivate\nand it will bring you back to your base environment.",
    "crumbs": [
      "Github",
      "Tutorials",
      "Virtual Environments"
    ]
  },
  {
    "objectID": "gh/renv.html#step-3-change-directories",
    "href": "gh/renv.html#step-3-change-directories",
    "title": "Virtual Environments",
    "section": "Step 3: Change Directories",
    "text": "Step 3: Change Directories\nChange the directory of the prompt to the repo’s directory. The code is\ncd C:/Users/XXXXXXX/Projects/Sequencing_2.0\nIf you are already in your user directory, you can just type\ncd projects/sequencing_2.0\ncapitalization doesn’t matter\n\n\nNotice that the folder path is now changed to the sequencing repo folder.",
    "crumbs": [
      "Github",
      "Tutorials",
      "Virtual Environments"
    ]
  },
  {
    "objectID": "gh/renv.html#step-4-copy-the-repo-env",
    "href": "gh/renv.html#step-4-copy-the-repo-env",
    "title": "Virtual Environments",
    "section": "Step 4: Copy the repo env",
    "text": "Step 4: Copy the repo env\nNow we’re ready to create a new environment based on the repo’s environment.\nType: conda env create --name seq_env --file=environment.yml\nNote that how you name your environment doesn’t really matter, but name it something that resembles the repo. This will save the headache of having random environments for random repos that you can’t remember..\n\n\nconda env create will create a new environment in your C:/Users/XXXXX/Anaconda3/envs file path\n--name or -n will name that environment, in this case seq_env\n--file=environment.yml this code will take the file in the sequencing 2.0 repo and use it to create this environment. It is essentially a copy of the software versions in the file.\n\nNote: I sped up the gif below. The whole process may take a few minutes",
    "crumbs": [
      "Github",
      "Tutorials",
      "Virtual Environments"
    ]
  },
  {
    "objectID": "gh/renv.html#step-5-activate-the-environment",
    "href": "gh/renv.html#step-5-activate-the-environment",
    "title": "Virtual Environments",
    "section": "Step 5: Activate the environment",
    "text": "Step 5: Activate the environment\nYou can switch between environments in the conda prompt or in a programming IDE (or both? idk). To activate and switch the env, write:\nconda activate &lt;env_name&gt;\nin this case\nconda activate seq_env\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe environment your in will show on the left of the prompt message. In this case it says (seq_env) instead of (base). That way you know what env your working in",
    "crumbs": [
      "Github",
      "Tutorials",
      "Virtual Environments"
    ]
  },
  {
    "objectID": "gh/renv.html#ide-setup---vs-code",
    "href": "gh/renv.html#ide-setup---vs-code",
    "title": "Virtual Environments",
    "section": "IDE Setup - VS Code",
    "text": "IDE Setup - VS Code\nVS Code has a lot built in to use a conda environment. Since your env is already activated, if you have VS Code installed, you can type\ncode\ninto the anaconda prompt and it will open a VS Code window\n\n\nStep 1: Select a Python Interpreter\nFirst we need to select a python interpreter, which is in our env. On your keyboard, press\nCTRL+SHIFT+P\nThis should bring up a window with an option that says Python: Select Interpreter. You may need to search for it.\nClick it and you should see your new environment seq_env in the list. Click it\n\n\n\nStep 2: Write code\nNow your VS Code is using your environment and the python version/packages in that environment. Check to see that your terminal is using the correct env.\nOpen the terminal (terminal &gt; new terminal) and confirm that you are in a cmd prompt in the terminal. On the right side of the terminal it should say cmd. If it says powershell or something else, let’s change it.. See the pic below. There’s a drop down that gives you shell types. Change your default to Command Prompt\n\n\nAlso notice in the picture that my environment now switches to seq_env. Yours should do the same. You should now be able to run code in a python script. Notice that your terminal will change to run python. If you get an error, write python in the terminal and hit enter. It will change your terminal a little. Now you can run python code and it will output to this terminal.",
    "crumbs": [
      "Github",
      "Tutorials",
      "Virtual Environments"
    ]
  },
  {
    "objectID": "gh/renv.html#ide-setup---pycharm",
    "href": "gh/renv.html#ide-setup---pycharm",
    "title": "Virtual Environments",
    "section": "IDE Setup - PyCharm",
    "text": "IDE Setup - PyCharm\nPyCharm also works great with a conda environment.\n\nStep 1: Select a Python Interpreter\nYou may also be able to open a PyCharm window from an Anaconda prompt like with VS Code (if it’s installed in your env). To do so, write pycharm in the prompt and it should open a new window with the env activated.\nIf that doesn’t work, open PyCharm and on the bottom right there is a python version and interpreter selected. Click it and open “Add New Interpreter” &gt; “Add local interpreter”. This opens a new window. Click “Conda Environment” and under “Interpreter” click the dropdown. You should be able to see your new environment there. If not, click away and click the dropdown again. It’s weird sometimes.\nThen click okay. Close and reopen the Python Console window and it should have your environment path for the python.exe. Also, the Python Libraries window should have all of the libraries in your environment now.\n\n\nNotice that now there are a list of interpreters for you to use. You can now switch back and forth between environments. This is great if you have other repos to use or want to test out new packages that aren’t in the main environment.",
    "crumbs": [
      "Github",
      "Tutorials",
      "Virtual Environments"
    ]
  },
  {
    "objectID": "gh/renv.html#step-1-install-a-new-package",
    "href": "gh/renv.html#step-1-install-a-new-package",
    "title": "Virtual Environments",
    "section": "Step 1: Install a new package",
    "text": "Step 1: Install a new package\nGo to the Anaconda prompt, make sure you’re in the repo file path (cd projects/sequencing_2.0) and make sure you’re in the right conda env (conda activate seq_env).\nNow, install the package. Usually packages can be installed with pip install or conda install or conda install -c conda forge &lt;package&gt;. This depends on the packages. Some need pip, others need conda. Google it to find out. Here i’m going to download a package from NCBI to demonstrate. The package is called ncbi-datasets-cli.\n\nThis package uses conda-forge to install. Type in conda install -c conda-forge ncbi-datasets-cli\nIt will give you a message Y/N to confirm. Type “y” and enter",
    "crumbs": [
      "Github",
      "Tutorials",
      "Virtual Environments"
    ]
  },
  {
    "objectID": "gh/renv.html#step-2-save-the-package-to-the-repo",
    "href": "gh/renv.html#step-2-save-the-package-to-the-repo",
    "title": "Virtual Environments",
    "section": "Step 2: Save the package to the repo",
    "text": "Step 2: Save the package to the repo\nNow we need to save this package to the repo’s environment.yml\n\nType conda env export &gt; environment.yml\nSince the package is in your environment, this code is exporting your new environment to repo’s one.\nNow push to github",
    "crumbs": [
      "Github",
      "Tutorials",
      "Virtual Environments"
    ]
  },
  {
    "objectID": "gh/renv.html#creating-renv-in-a-project",
    "href": "gh/renv.html#creating-renv-in-a-project",
    "title": "Virtual Environments",
    "section": "Creating renv in a project",
    "text": "Creating renv in a project\n\nStep 1: Open the .Rproj in your repo\nThe R project will open up Rstudio at the root of you directory path.\n\n\n\nStep 2: Initialize renv for the repo\nNow that we’re in the root of your repo directory, let’s initialize renv.\nFirst install renv - install.packages(\"renv\")\nThen in your console write renv::init() and run it.\n\nIf you already have an existing repo, you will probably see warnings and errors in the renv::init like I did in the gif above. Not to worry! Read the warnings and follow the instructions. Usually you will need to re-install a package. If you get this warning:\nThese may be left over from a prior, failed installation attempt.\nConsider removing or reinstalling these packages.\n\nThen run renv::install(\"THAT PACKAGE\"). It will install the package again,\nand then you need to update the lock file (more on that later) by running renv::snapshot().\n\nNow the package will be installed correctly\n\nrenv::init() will:\n\nSearch through all R scripts in your repo and find all packages used\nCreate a snapshot of those packages\nSave all packages in the repo in a new renv libraries path (similar to your C drive R libraries paths)\nCreate a .gitignore within the renv libraries path so that you don’t get spammed with thousands of libraries in your git commit\nCreate a lock file - this is like the environment.yml for conda. Think of it as instructions for which packages your repo is using\nIt also saved things like an activate R script which will activate that renv every time the repo is opened from the .Rproj\n\n\n\nStep 3: Push to Github\nNow look at your git stage and you will see all the files renv created.\nWe have\n\n.Rprofile that contains an renv activate.R script - this will activate the repo’s renv every time the project is opened\nThe renv.lock file shows information on each package used in the repo and is used to update collaborator’s environments to match the lock file.\nrenv/.gitignore I don’t feel like explaining this one right now - i’ll write more later\nrenv/activate.R this will activate the env whenever the R project is opened\nrenv/settings.dcf I have no clue what this is",
    "crumbs": [
      "Github",
      "Tutorials",
      "Virtual Environments"
    ]
  },
  {
    "objectID": "gh/renv.html#using-renv-in-a-project",
    "href": "gh/renv.html#using-renv-in-a-project",
    "title": "Virtual Environments",
    "section": "Using renv in a project",
    "text": "Using renv in a project\n\nStep 1: Open the .Rproj for your repo\nAny time you need to code or run code from the repo, open up the .Rproj file that contains the sequencing 2.0 project. In your file explorer, go to the repo and open Sequencing_2.0 .Rproj\n\nThis will open up an R window with the repo file path as a root directory. It will also utilize the renv. Your console should say something about renv, like this\n\n\n\nStep 2: Load renv packages\nThe first time you use renv you will need to configure it to your local machine. To do this, type:\n\nrenv::restore() in your console.\nThis will create a new environment for your R in your local machine using the lock file packages.\n\n\nNow you’re ready to use the scripts! Way less complicated than conda",
    "crumbs": [
      "Github",
      "Tutorials",
      "Virtual Environments"
    ]
  },
  {
    "objectID": "gh/templates.html",
    "href": "gh/templates.html",
    "title": "Templates",
    "section": "",
    "text": "This is a Github repo template for R projects. It has renv set up and a .devcontainer for reproducibility\n\n\n\nSelect Use Template &gt; NW-PaGe/R_template when creating a new repo in the NW-PaGe org. The template comes with a pre-filled README.md file that you can edit to your own needs. It’s recommended to leave the .devconainter folder in this repo. It serves as instructions to install all the software and R packages needed to reproduce the repos code using a Github Codespace. See the README.md for more information.",
    "crumbs": [
      "Github",
      "Tutorials",
      "Templates"
    ]
  },
  {
    "objectID": "gh/templates.html#r-github-template",
    "href": "gh/templates.html#r-github-template",
    "title": "Templates",
    "section": "",
    "text": "This is a Github repo template for R projects. It has renv set up and a .devcontainer for reproducibility\n\n\n\nSelect Use Template &gt; NW-PaGe/R_template when creating a new repo in the NW-PaGe org. The template comes with a pre-filled README.md file that you can edit to your own needs. It’s recommended to leave the .devconainter folder in this repo. It serves as instructions to install all the software and R packages needed to reproduce the repos code using a Github Codespace. See the README.md for more information.",
    "crumbs": [
      "Github",
      "Tutorials",
      "Templates"
    ]
  },
  {
    "objectID": "gh/templates.html#purpledoc-quarto-template",
    "href": "gh/templates.html#purpledoc-quarto-template",
    "title": "Templates",
    "section": "Purpledoc Quarto Template",
    "text": "Purpledoc Quarto Template\nThis is a Quarto template that contains the style and images used in this site\n\n\n\nquarto use template coe-test-org/purpledoc\nThis will install the extension and create an example qmd file that you can use as a starting place for your report.\nYou may also use this format with an existing Quarto project or document. From the quarto project or document directory, run the following command to install this format:\nquarto add coe-test-org/purpledoc",
    "crumbs": [
      "Github",
      "Tutorials",
      "Templates"
    ]
  },
  {
    "objectID": "gh/lic.html",
    "href": "gh/lic.html",
    "title": "Licensing",
    "section": "",
    "text": "Summary\n\nLicenses prevent code theft and inappropriate redistribution of code.\nReview common open-source licenses\nLicense types vary depending on repo goals\n\n\n\n\nGeneral License Info\nBelow is a list of common open-source licenses.\n\n\nThere isn’t a one size fits all license, so thankfully there are a variety of options. Here are two common ones:\n\n\nGNU GPL licenses\n\nThese are the strong licenses\nPrevents someone from taking our code and privatizing it (and making money off of it)\nSomeone can still use our code, they just need to ensure that what they’re doing with it is open-source\n“Copyright and license notices must be preserved.”\n“Contributors provide an express grant of patent rights. When a modified version is used to provide a service over a network, the complete source code of the modified version must be made available.”\n\n\n\nMIT license\n\nI think this is the most commonly used one\n“short and simple permissive license… only requiring preservation of copyright and license notices”\n“Licensed works, modifications, and larger works may be distributed under different terms and without source code.”\nSomeone could basically do whatever they want with the code.\nNextstain/ncov repo is currently using this\n\nAnd here are a couple of youtube videos that were helping in explaining licensing",
    "crumbs": [
      "Github",
      "Policies",
      "Licensing"
    ]
  },
  {
    "objectID": "aws/aws_index.html",
    "href": "aws/aws_index.html",
    "title": "something",
    "section": "",
    "text": "something\nhere",
    "crumbs": [
      "AWS",
      "something"
    ]
  }
]