[
  {
    "objectID": "tools/link_code.html",
    "href": "tools/link_code.html",
    "title": "Link external R code to the documentation",
    "section": "",
    "text": "The code in this website is automatically linked to the code in the repository. This lets us update the code and not need to copy and paste any new changes to the documentation/github page\nTo do this, open your external R script in your repo. In this case we’re using lineages_public_repo.R. Now wrap the chunks of code you want to link with comments like this, ## ---- libraries and ## ---- stop:\n\n\n\n## ---- libraries\nlibrary(pacman)\np_load(\n  reticulate,\n  fs,\n  lubridate,\n  dplyr,\n  stringr,\n  magrittr,\n  readr,\n  httr\n)\n## ---- stop\n\n\n\nThe ## ---- libraries signals the beginning of a chunk. the ## ---- stop signals the end of a chunk.\n\nNow you can call this chunk in your github page/quarto document like this:\nScan the external R script for code chunks:\n\n```{r setup}\n#| echo: false\nknitr::read_chunk(file.path(getwd(),\"lineages_public_repo.R\"))\n```\n\n\nCall the code chunk you want in the {r} header within the chunk. like this {r libraries}:\n\n```{r libraries}\n\n```\n\n\nAnd now the document will output any code in that code chunk and can also execute that code chunk if you want. Here’s what the output will look like in this case:"
  },
  {
    "objectID": "tools/how_to.html",
    "href": "tools/how_to.html",
    "title": "Code and Repo Documentation",
    "section": "",
    "text": "This site was created using Quarto, Github, and uses a Github Action to automatically render when a commit is pushed to the main branch of this repository.\nQuarto is a framework for creating documentation, slideshows, articles, blogs, books and websites using markdown. It can execute R, Python and other programming languages within the document.\nGithub Actions uses a .yml file in the repository to trigger an action based on a certain event. In this case, when a commit is pushed to the main branch the .yml will trigger this Quarto website to render to the gh-pages branch of the repository and publish the github page. This section will give details on how to\n\nCreate the website\nCreate, edit, and troubleshoot the Github Action to render the site"
  },
  {
    "objectID": "tools/how_to.html#editadd-sections-and-chapters",
    "href": "tools/how_to.html#editadd-sections-and-chapters",
    "title": "Code and Repo Documentation",
    "section": "Edit/Add Sections and Chapters",
    "text": "Edit/Add Sections and Chapters\nTo add a section, open up the _quarto.yml file and scroll to the navbar section\n\n\n\n\n_quarto.yml\n\nproject:\n  type: website\nwebsite:\n  title: \"COE Github Standards\"\n  search: true\n  \n  navbar: \n    background: primary\n    left: \n      - text: Home\n        href: index.qmd\n      - text: Github Organization Standards\n        menu: \n          - href: std/security.qmd\n            text: \"0: Security Standards\"\n          - href: std/lic.qmd\n            text: \"1: Choosing a License\"\n          - href: std/templates.qmd\n            text: \"2: Org Policy Setting\"\n\n\n\n\nThis is where all of the qmd files are sourced and the instructions on how to format and style the navigation bar in the website.\nCurrently, the project is set up to have each section have it’s own drop down menu in the navbar. In a section, use - href: to specify a file and text: to give the file a custom name in the website.\nEach chapter exists within a sub-folder, so to add a chapter make sure create the qmd in its sub-folder and then reference the sub-folder and chapter in the .yml. For example, if you make a new chapter called new-chapter.qmd and it exists in the covid section/sub-folder, you need to reference it in the .yml file like: covid/new-chapter.qmd"
  },
  {
    "objectID": "tools/how_to.html#website-style",
    "href": "tools/how_to.html#website-style",
    "title": "Code and Repo Documentation",
    "section": "Website Style",
    "text": "Website Style\nYou can customize many aspects of the website in the .yml file itself with the format: function. There are a ton of themes included in Quarto here and you can also add a custom css and/or scss file to your project. I think you can even go super in depth and customize the javascript components of the site, but I’m not entirely sure how to do that yet. This website has a ton of custom css components with Quarto, and possibly uses custom javascript, so it could be a place to start if you’re interested. Basically, you need to embed the css file into your _quarto.yml file\n\n\n\n\n_quarto.yml\n\nformat:\n  html:\n    theme: \n      - cosmo\n      - assets/styles.scss\n    scss: assets/styles.scss\n    # css: styles.css\n    toc: true\n    highlight-style: assets/custom.theme"
  },
  {
    "objectID": "tools/how_to.html#open-the-r-project",
    "href": "tools/how_to.html#open-the-r-project",
    "title": "Code and Repo Documentation",
    "section": "Open the R project",
    "text": "Open the R project\nThis is a Quarto website that is contained in a .rproj file path. The R project contains all the documents used to create this website. Begin by opening the R project when should be in your local clone under C:\\Users\\XXXXXXX\\Projects\\Sequencing_2.0\\sequencing_documentation\\sequencing_documentation.Rproj"
  },
  {
    "objectID": "tools/how_to.html#open-the-files",
    "href": "tools/how_to.html#open-the-files",
    "title": "Code and Repo Documentation",
    "section": "Open the files",
    "text": "Open the files\nThis project has .qmd files (Quarto Markdown files) that each represent a chapter in the website. All of the .qmd files are knitted together (using R knitr) which compiles all of the files to be sourced into htmls.\nThis website is set up to have each major section contain multiple chapters. To open a chapter, the bottom right pane in your R Studio window should contain folders for each section, highlighted below\n\n\n$ tree /f\nC:.\n│   .gitignore\n│   about.qmd\n│   index.qmd\n│   standards.Rproj\n│   _quarto.yml\n│\n├───assets\n│       custom.theme\n│       styles.css\n│       styles.scss\n│\n├───std\n│   │   creds.qmd\n│   │   lic.qmd\n│   │   public_code.qmd\n│   │   security.qmd\n│   │   templates.qmd\n│   │\n│   └───images\n│\n├───tools\n│   │   how_to.qmd\n│   │   iac.qmd\n│   │   link_code.qmd\n│   │   readme.qmd\n│   │   release.qmd\n│   │   renv.qmd\n│   │   teams.qmd\n│   │\n│   └───images\n\nError in running command bash\n\n\n\n\nThe .qmd files are inside of these folders. Select one to edit."
  },
  {
    "objectID": "tools/how_to.html#commit-changes",
    "href": "tools/how_to.html#commit-changes",
    "title": "Code and Repo Documentation",
    "section": "Commit changes",
    "text": "Commit changes\nOnce you’re done editing, push the change to the main branch (or make a new branch, and then a pull request for the main branch). More one this in the git chapter"
  },
  {
    "objectID": "tools/how_to.html#example-yaml-workflow",
    "href": "tools/how_to.html#example-yaml-workflow",
    "title": "Code and Repo Documentation",
    "section": "Example YAML Workflow",
    "text": "Example YAML Workflow\nThe .yml workflow for this project looks something like this:\non: is a tag indicating when the action will run. Right now it will run when any code gets pushed to the main branch in the documentation folder or lineages_public_repo.R script\n\n\n\n\nquarto-publish.yml\n\non: \n  push:\n    branches:\n      - main\n    paths:\n      - documentation/**\n      - lineages_public_repo.R\n\n\n\njobs: is a tag that tells a Github virtual machine what to run and what operating system to run it on. In this case ubuntu with the latest version. This can be windows, linux or macOS.\n\n\n\n\nquarto-publish.yml\n\nname: Render and Publish\n\njobs:\n  build-deploy:\n    runs-on: ubuntu-latest\n\n\n\n\nNow we have the steps:\n\nenv will find the renv folder\nuses: actions/checkout@v3 will refresh the repo and pull the latest changes\nuses: quarto-dev/quarto-actions/setup@v2 will install quarto\nuses: actions/cache@v1 and the code below it will set up renv and use the cached packages to install them onto the Github virtual machine\n\n\n\n\n\nquarto-publish.yml\n\n    env:\n      RENV_PATHS_ROOT: ~/.cache/R/renv\n      \n    steps:\n      - name: Check out repository\n        uses: actions/checkout@v3\n        \n      - name: Set up Quarto\n        uses: quarto-dev/quarto-actions/setup@v2\n        \n      - name: Prep CURL install\n        run: sudo apt-get update\n\n      - name: Install CURL Headers\n        run: sudo apt-get install libcurl4-openssl-dev\n\n      # - name: Setup Renv\n      #   uses: r-lib/actions/setup-renv@v2\n  \n      - name: Cache packages\n        uses: actions/cache@v1\n        with:\n          path: ${{ env.RENV_PATHS_ROOT }}\n          key: ${{ runner.os }}-renv-${{ hashFiles('**/renv.lock') }}\n          restore-keys: |\n            ${{ runner.os }}-renv-\n      \n      - name: Restore packages\n        shell: Rscript {0}\n        run: |\n          if (!requireNamespace(\"renv\", quietly = TRUE)) install.packages(\"renv\")\n          renv::restore()\n\n\n\n\nAnd finally,\n\nuses: quarto-dev/quarto-actions/publish@v2 will render the site by running quarto render\nwith: target: gh-pages path: documentation/_site lets you know which branch and path to render the site to\n\n\n\n\n\nquarto-publish.yml\n\n      - name: Publish to GitHub Pages (and render)\n        uses: quarto-dev/quarto-actions/publish@v2\n        with:\n          target: gh-pages\n          path: documentation/_site\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # this secret is always available for github actions"
  },
  {
    "objectID": "tools/how_to.html#using-renv-in-the-gh-action",
    "href": "tools/how_to.html#using-renv-in-the-gh-action",
    "title": "Code and Repo Documentation",
    "section": "Using renv in the GH Action",
    "text": "Using renv in the GH Action\nIf you need to constantly update your website with code chunk, this is the best way to do it. It is also probably safer and better than the _freeze way, but it requires a better understanding of Github Actions and virtual environments.\nrenv is an R package for creating a project level virtual environment. In other words, renv will create project specific folders that contain the specific R package versions you use in an project. More on this here\nTo use renv in a Github Action, you can put\n\n\n\n\nquarto-publish.yml\n\n- name: Setup Renv\n  uses: r-lib/actions/setup-renv@v2\n\n\n\nor use the renv cache code in the yaml section above"
  },
  {
    "objectID": "tools/how_to.html#using-a-_freeze-file",
    "href": "tools/how_to.html#using-a-_freeze-file",
    "title": "Code and Repo Documentation",
    "section": "Using a _freeze file",
    "text": "Using a _freeze file\nIf you only need to execute the code once or just need to render a non-executable code chunk once, make sure you have this code in your _quarto.yml file:\n\n\n\n\n_quarto.yml\n\nexecute:\n  error: true\n  freeze: true\n\n\n\nand then run this in your terminal window:\nquarto render name-of-specific-document-or-chapter.qmd\nThis will render that specific document in the website, execute code chunks if they are set to execute (eval: true) and then it will create a _freeze file. The _freeze file will save a snapshot of that specific document and not re-render it in the Github Action. This means you can render other parts of the website, but any files in the _freeze folder will stay the same as they are in the freeze. If you need to make changes to a freeze document, run the quarto render code again after making changes.\nThis is also documented in the Quarto dev documentation"
  },
  {
    "objectID": "tools/how_to.html#troubleshooting",
    "href": "tools/how_to.html#troubleshooting",
    "title": "Code and Repo Documentation",
    "section": "Troubleshooting",
    "text": "Troubleshooting\nSo you did these steps:\n\nCreate the quarto-publish.yml\nRun quarto publish gh-pages in the terminal\nPush all the files in your git to the main branch\n\nIf this works on your first try then the universe is taking extra special care of you.\nIf not, you are like the rest of us poor souls:/\n\nThe first thing I would check is the error in your Github repo’s Action tab.\nIf the error is something like jsonlite not installed or some package not installed then it most likely means your are trying to commit a chunk of code in the documentation. Even if you are not executing the code, Github Actions will punish you. There are a couple options to fix this, depending on your priorities.\n\nIf you don’t care about executing your code and/or only need to push that part of the script once, consider using the _freeze option\nIf you need to execute code or need to programmtically render the document with code chunks often, consider using renv or a similar package installation method"
  },
  {
    "objectID": "tools/renv.html",
    "href": "tools/renv.html",
    "title": "Virtual Environments",
    "section": "",
    "text": "Virtual environments allow us to execute code while accounting for software/package version differences we have on our local machines. This repo uses virtual environments to configure a user’s R and Python software and packages to the repo’s specific package versions.\nFor example, say you have dplyr version 2.0 but this repo uses dplyr version 1.1, you may not be able to run the scripts as intended by the author since the functions in dplyr 1.1 may be different than in 2.0. The virtual environment will allow a given user to use only this repo’s version of dplyr so they can run the code as intended.\n\n\n\n\n\n\nImportant\n\n\n\nThere are two different virtual environments for this repo, one for R and another for Python. Your workflows for opening R and Python and how you install packages needs to utilize the virtual environments so that all machines are able to use your code."
  },
  {
    "objectID": "tools/renv.html#step-1-set-up-anaconda",
    "href": "tools/renv.html#step-1-set-up-anaconda",
    "title": "Virtual Environments",
    "section": "Step 1: Set Up Anaconda",
    "text": "Step 1: Set Up Anaconda\nYou should already have Anaconda installed on your machine if not..\nunder construction"
  },
  {
    "objectID": "tools/renv.html#step-2-open-anaconda-prompt",
    "href": "tools/renv.html#step-2-open-anaconda-prompt",
    "title": "Virtual Environments",
    "section": "Step 2: Open Anaconda Prompt",
    "text": "Step 2: Open Anaconda Prompt\nYou may have different Anaconda prompts (prompts aligned with different shells, like PowerShell, bash, etc). There should be a generic Anaconda prompt. Open that one:\n\n\nIf the first line in the prompt doesn’t start with (base), write:\nconda deactivate\nand it will bring you back to your base environment."
  },
  {
    "objectID": "tools/renv.html#step-3-change-directories",
    "href": "tools/renv.html#step-3-change-directories",
    "title": "Virtual Environments",
    "section": "Step 3: Change Directories",
    "text": "Step 3: Change Directories\nChange the directory of the prompt to the repo’s directory. The code is\ncd C:/Users/XXXXXXX/Projects/Sequencing_2.0\nIf you are already in your user directory, you can just type\ncd projects/sequencing_2.0\ncapitalization doesn’t matter\n\n\nNotice that the folder path is now changed to the sequencing repo folder."
  },
  {
    "objectID": "tools/renv.html#step-4-copy-the-repo-env",
    "href": "tools/renv.html#step-4-copy-the-repo-env",
    "title": "Virtual Environments",
    "section": "Step 4: Copy the repo env",
    "text": "Step 4: Copy the repo env\nNow we’re ready to create a new environment based on the repo’s environment.\nType: conda env create --name seq_env --file=environment.yml\nNote that how you name your environment doesn’t really matter, but name it something that resembles the repo. This will save the headache of having random environments for random repos that you can’t remember..\n\n\nconda env create will create a new environment in your C:/Users/XXXXX/Anaconda3/envs file path\n--name or -n will name that environment, in this case seq_env\n--file=environment.yml this code will take the file in the sequencing 2.0 repo and use it to create this environment. It is essentially a copy of the software versions in the file.\n\nNote: I sped up the gif below. The whole process may take a few minutes"
  },
  {
    "objectID": "tools/renv.html#step-5-activate-the-environment",
    "href": "tools/renv.html#step-5-activate-the-environment",
    "title": "Virtual Environments",
    "section": "Step 5: Activate the environment",
    "text": "Step 5: Activate the environment\nYou can switch between environments in the conda prompt or in a programming IDE (or both? idk). To activate and switch the env, write:\nconda activate &lt;env_name&gt;\nin this case\nconda activate seq_env\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe environment your in will show on the left of the prompt message. In this case it says (seq_env) instead of (base). That way you know what env your working in"
  },
  {
    "objectID": "tools/renv.html#ide-setup---vs-code",
    "href": "tools/renv.html#ide-setup---vs-code",
    "title": "Virtual Environments",
    "section": "IDE Setup - VS Code",
    "text": "IDE Setup - VS Code\nVS Code has a lot built in to use a conda environment. Since your env is already activated, if you have VS Code installed, you can type\ncode\ninto the anaconda prompt and it will open a VS Code window\n\n\nStep 1: Select a Python Interpreter\nFirst we need to select a python interpreter, which is in our env. On your keyboard, press\nCTRL+SHIFT+P\nThis should bring up a window with an option that says Python: Select Interpreter. You may need to search for it.\nClick it and you should see your new environment seq_env in the list. Click it\n\n\n\nStep 2: Write code\nNow your VS Code is using your environment and the python version/packages in that environment. Check to see that your terminal is using the correct env.\nOpen the terminal (terminal &gt; new terminal) and confirm that you are in a cmd prompt in the terminal. On the right side of the terminal it should say cmd. If it says powershell or something else, let’s change it.. See the pic below. There’s a drop down that gives you shell types. Change your default to Command Prompt\n\n\nAlso notice in the picture that my environment now switches to seq_env. Yours should do the same. You should now be able to run code in a python script. Notice that your terminal will change to run python. If you get an error, write python in the terminal and hit enter. It will change your terminal a little. Now you can run python code and it will output to this terminal."
  },
  {
    "objectID": "tools/renv.html#ide-setup---pycharm",
    "href": "tools/renv.html#ide-setup---pycharm",
    "title": "Virtual Environments",
    "section": "IDE Setup - PyCharm",
    "text": "IDE Setup - PyCharm\nPyCharm also works great with a conda environment.\n\nStep 1: Select a Python Interpreter\nYou may also be able to open a PyCharm window from an Anaconda prompt like with VS Code (if it’s installed in your env). To do so, write pycharm in the prompt and it should open a new window with the env activated.\nIf that doesn’t work, open PyCharm and on the bottom right there is a python version and interpreter selected. Click it and open “Add New Interpreter” &gt; “Add local interpreter”. This opens a new window. Click “Conda Environment” and under “Interpreter” click the dropdown. You should be able to see your new environment there. If not, click away and click the dropdown again. It’s weird sometimes.\nThen click okay. Close and reopen the Python Console window and it should have your environment path for the python.exe. Also, the Python Libraries window should have all of the libraries in your environment now.\n\n\nNotice that now there are a list of interpreters for you to use. You can now switch back and forth between environments. This is great if you have other repos to use or want to test out new packages that aren’t in the main environment."
  },
  {
    "objectID": "tools/renv.html#step-1-install-a-new-package",
    "href": "tools/renv.html#step-1-install-a-new-package",
    "title": "Virtual Environments",
    "section": "Step 1: Install a new package",
    "text": "Step 1: Install a new package\nGo to the Anaconda prompt, make sure you’re in the repo file path (cd projects/sequencing_2.0) and make sure you’re in the right conda env (conda activate seq_env).\nNow, install the package. Usually packages can be installed with pip install or conda install or conda install -c conda forge &lt;package&gt;. This depends on the packages. Some need pip, others need conda. Google it to find out. Here i’m going to download a package from NCBI to demonstrate. The package is called ncbi-datasets-cli.\n\nThis package uses conda-forge to install. Type in conda install -c conda-forge ncbi-datasets-cli\nIt will give you a message Y/N to confirm. Type “y” and enter"
  },
  {
    "objectID": "tools/renv.html#step-2-save-the-package-to-the-repo",
    "href": "tools/renv.html#step-2-save-the-package-to-the-repo",
    "title": "Virtual Environments",
    "section": "Step 2: Save the package to the repo",
    "text": "Step 2: Save the package to the repo\nNow we need to save this package to the repo’s environment.yml\n\nType conda env export &gt; environment.yml\nSince the package is in your environment, this code is exporting your new environment to repo’s one.\nNow push to github"
  },
  {
    "objectID": "tools/renv.html#creating-renv-in-a-project",
    "href": "tools/renv.html#creating-renv-in-a-project",
    "title": "Virtual Environments",
    "section": "Creating renv in a project",
    "text": "Creating renv in a project\n\nStep 1: Open the .Rproj in your repo\nThe R project will open up Rstudio at the root of you directory path.\n\n\n\nStep 2: Initialize renv for the repo\nNow that we’re in the root of your repo directory, let’s initialize renv.\nFirst install renv - install.packages(\"renv\")\nThen in your console write renv::init() and run it.\n\nIf you already have an existing repo, you will probably see warnings and errors in the renv::init like I did in the gif above. Not to worry! Read the warnings and follow the instructions. Usually you will need to re-install a package. If you get this warning:\nThese may be left over from a prior, failed installation attempt.\nConsider removing or reinstalling these packages.\n\nThen run renv::install(\"THAT PACKAGE\"). It will install the package again,\nand then you need to update the lock file (more on that later) by running renv::snapshot().\n\nNow the package will be installed correctly\n\nrenv::init() will:\n\nSearch through all R scripts in your repo and find all packages used\nCreate a snapshot of those packages\nSave all packages in the repo in a new renv libraries path (similar to your C drive R libraries paths)\nCreate a .gitignore within the renv libraries path so that you don’t get spammed with thousands of libraries in your git commit\nCreate a lock file - this is like the environment.yml for conda. Think of it as instructions for which packages your repo is using\nIt also saved things like an activate R script which will activate that renv every time the repo is opened from the .Rproj\n\n\n\nStep 3: Push to Github\nNow look at your git stage and you will see all the files renv created.\nWe have\n\n.Rprofile that contains an renv activate.R script - this will activate the repo’s renv every time the project is opened\nThe renv.lock file shows information on each package used in the repo and is used to update collaborator’s environments to match the lock file.\nrenv/.gitignore I don’t feel like explaining this one right now - i’ll write more later\nrenv/activate.R this will activate the env whenever the R project is opened\nrenv/settings.dcf I have no clue what this is"
  },
  {
    "objectID": "tools/renv.html#using-renv-in-a-project",
    "href": "tools/renv.html#using-renv-in-a-project",
    "title": "Virtual Environments",
    "section": "Using renv in a project",
    "text": "Using renv in a project\n\nStep 1: Open the .Rproj for your repo\nAny time you need to code or run code from the repo, open up the .Rproj file that contains the sequencing 2.0 project. In your file explorer, go to the repo and open Sequencing_2.0 .Rproj\n\nThis will open up an R window with the repo file path as a root directory. It will also utilize the renv. Your console should say something about renv, like this\n\n\n\nStep 2: Load renv packages\nThe first time you use renv you will need to configure it to your local machine. To do this, type:\n\nrenv::restore() in your console.\nThis will create a new environment for your R in your local machine using the lock file packages.\n\n\nNow you’re ready to use the scripts! Way less complicated than conda"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "\n\nNORTHWEST PATHOGEN GENOMICS CENTER OF EXCELLENCE\n\nPolicies and Guidelines\n",
    "section": "",
    "text": "NORTHWEST PATHOGEN GENOMICS CENTER OF EXCELLENCE\n\nPolicies and Guidelines\n\nThis is a static website documenting the policies and guidelines for public Github use at the Pacific Northwest Genomic Center of Excellence. Scroll below to see overviews on Github, Azure, and AWS policies.\nGet started\n\n\n\n\n\n\n  \n\n\n\n\nGithub Policies\n\nRepo security rules \nLicensing \nTemplates and guides \n\ngh guides\n\n\n\nAWS Policies\n\nRepo AWS rules \nDocumentation \nUser guides \n\naws guides\n\n\n\nAzure Policies\n\nRepo Azure/Databricks rules \nDocumentation \nUser guides \n\nazure guides"
  },
  {
    "objectID": "gh/link_code.html",
    "href": "gh/link_code.html",
    "title": "Link external R code to the documentation",
    "section": "",
    "text": "The code in this website is automatically linked to the code in the repository. This lets us update the code and not need to copy and paste any new changes to the documentation/github page\nTo do this, open your external R script in your repo. In this case we’re using lineages_public_repo.R. Now wrap the chunks of code you want to link with comments like this, ## ---- libraries and ## ---- stop:\n\n\n\n## ---- libraries\nlibrary(pacman)\np_load(\n  reticulate,\n  fs,\n  lubridate,\n  dplyr,\n  stringr,\n  magrittr,\n  readr,\n  httr\n)\n## ---- stop\n\n\n\nThe ## ---- libraries signals the beginning of a chunk. the ## ---- stop signals the end of a chunk.\n\nNow you can call this chunk in your github page/quarto document like this:\nScan the external R script for code chunks:\n\n```{r setup}\n#| echo: false\nknitr::read_chunk(file.path(getwd(),\"lineages_public_repo.R\"))\n```\n\n\nCall the code chunk you want in the {r} header within the chunk. like this {r libraries}:\n\n```{r libraries}\n\n```\n\n\nAnd now the document will output any code in that code chunk and can also execute that code chunk if you want. Here’s what the output will look like in this case:"
  },
  {
    "objectID": "gh/contribute.html",
    "href": "gh/contribute.html",
    "title": "Contribution/Collaboration Guide",
    "section": "",
    "text": "Summary\n\nThe Northwest Pathogen Genomics Center of Excellence (NW-PaGe) uses a public Github organization to host our code.\nIf you want to contribute to the organization, please read this guide and our security guidelines.\nYou will need Git and Github to make code contributions:",
    "crumbs": [
      "Github",
      "Policies",
      "Contribution/Collaboration Guide"
    ]
  },
  {
    "objectID": "gh/contribute.html#before-you-make-code-changes",
    "href": "gh/contribute.html#before-you-make-code-changes",
    "title": "Contribution/Collaboration Guide",
    "section": "Before you make code changes",
    "text": "Before you make code changes\nAfter creating a repo (Section 4) and/or cloning the repo (Section 5) into a your local machine, you can start writing and contributing code to the remote code base in Github.\n\nCheck that you have your local clone linked to the remote repo by running git status. It should tell you that you’re on the main branch\n\n\n\n\n\nterminal\n\ngit status\n\n\n\n\nWe need to refresh the repo and check for any code changes to make sure our local clone is up to date. Use git fetch to find changes and git pull to pull those changes into your local clone.\n\n\n\n\n\nterminal\n\ngit fetch\ngit pull\n\n\n\n\nMake a new branch so we can isolate your changes and prevent accidentally pushing code changes to the main branch\n\n\n\n\n\nterminal\n\ngit branch &lt;insert your branch name here&gt;\n\n\n\n\nSwitch to that branch\n\n\n\n\n\nterminal\n\ngit switch &lt;your branch name here&gt;\n\n\n\nNow you are working in the local branch that you created and you can begin writing code or making updates.",
    "crumbs": [
      "Github",
      "Policies",
      "Contribution/Collaboration Guide"
    ]
  },
  {
    "objectID": "gh/contribute.html#committing-your-changes",
    "href": "gh/contribute.html#committing-your-changes",
    "title": "Contribution/Collaboration Guide",
    "section": "Committing your changes",
    "text": "Committing your changes\nOnce you make changes you can commit them to the local branch you created. This is like saving your work to the branch. The branch can be pushed to the remote repo in Github, so you can continually make changes and push them to the remote where they will be stored safely.\nTo make a commit, save your work and then in the terminal write git commit -m \"&lt;your message here\", like this:\n\n\n\n\nterminal\n\ngit commit -m \"feat: this is a new feature!\"\n\n\n\nNote that the -m is a parameter to let you write a commit message. Commit messages are important so that other collaborators can understand what changes you made. You can write a description like this\n\n\n\n\nterminal\n\ngit commit -m \"feat: this is a new feature!\" \"this is a description. I made this feature in the code\"\n\n\n\nAlso note that I am using the word feat in the commit message. This is important word that can trigger a github action. We’ll cover it below in Section 6.5",
    "crumbs": [
      "Github",
      "Policies",
      "Contribution/Collaboration Guide"
    ]
  },
  {
    "objectID": "gh/contribute.html#make-a-pull-request",
    "href": "gh/contribute.html#make-a-pull-request",
    "title": "Contribution/Collaboration Guide",
    "section": "Make a pull request",
    "text": "Make a pull request\nNow you have committed your changes, but your code has only been committed to a branch. In order to have your changes implemented in the main codebase you need to merge your branch into the main branch.\nWhen working in a collaborative team setting it is important to have your team review the changes you made before implementing them into the main branch. Everyone makes mistakes, and this is an opportunity to vet your code and have everyone sign off on the changes you want.\nAfter you make your commits, go back to Github in your browser and go to your repo. There should be a box that appears showing your commit and a button that says Compare & pull request\n\nClick that button and it will bring you to the Open a pull request page.\n\nSelect who you want to review your code and assign yourself.\nUse labels to tag what this pull request refers to (very helpful in search for changes when managing the project) and\nAdd a milestone if it applies.\n\nNote that labels, milestones, and projects are a way to keep track of changes and issues in your project. I highly recommend setting them up, more below.\nThis should automatically send an email to the reviewers that there is code needed to be merged to a branch.",
    "crumbs": [
      "Github",
      "Policies",
      "Contribution/Collaboration Guide"
    ]
  },
  {
    "objectID": "gh/contribute.html#sec-merge",
    "href": "gh/contribute.html#sec-merge",
    "title": "Contribution/Collaboration Guide",
    "section": "Merging a branch to main",
    "text": "Merging a branch to main\nTypically your teammates and the repo admin will review your code and merge your branch into the main branch.\nIn Github, click on the Pull requests tab. Here you will see open pull requests and you can click on the one you want to merge.\n\n\n\nReview a pull request\n\n\n\nIn the pull request you will see 4 tabs;\n\nConversation tab that shows all the comments, descriptions, tags, and more.\nCommits tab that contains a list of all the commits made in this request\nChecks - if you have automated testing or apps in the repo you can trigger them with a pull request and see them here. For example, you can set up automated unit tests to run whenever a pull request is made. A github action will run the unit test and pass (or fail) here before it is merged to main.\nFiles changed - I personally always flip through this tab because it shows all the differences (diffs) between the old codebase and the new commits that were made.\n\n\n\n\nFiles Changed\n\n\n\nWhen you are comfortable with merging these changes, you can either leave a comment, approve, or request further changes by clicking on the Review changes dropdown menu.\n\n\n\nReview changes\n\n\n\nYou can leave inline comments in the commits by viewing the file of choice, and then hovering over the line of interest and clicking the + sign:\n\n\n\nview file\n\n\n\n\n\ninline comment\n\n\nThese comments will be tagged in the pull request and will need to be resolved by the person making the request before the code can get merged into the main branch.\n\nOnce the pull request has the approvals needed, you can merge it. Note, admins can customize how approvals work. We normally just have one admin or person required to approve a pull request for it to be mergeable. To state again, in the Review changes dropdown there is an option to approve the request - that is what is required.\n\n\n\nmerge\n\n\nAfter approval, hopefully you have a message that says This branch has no conflicts with the base branch. If there are conflicts it will prevent you from merging. We require the user who made the commit to resolve merge conflicts. The conflict typically happens when your branch is out of date and it is not lined up with the current main branch. You sometimes need to merge the main branch into your local branch and then commit those changes. This is very scenario dependent and requires some googling. Please reach out to us for help if this happens!",
    "crumbs": [
      "Github",
      "Policies",
      "Contribution/Collaboration Guide"
    ]
  },
  {
    "objectID": "gh/contribute.html#sec-changelog",
    "href": "gh/contribute.html#sec-changelog",
    "title": "Contribution/Collaboration Guide",
    "section": "Release Cycles and Changelogs",
    "text": "Release Cycles and Changelogs\nAs I mentioned before, I used special trigger words like feat or fix in commit messages. These words indicate that a commit contains a new code feature or a bug fix. They trigger a github action that will produce a changelog, documentation, and a version change in the code based when the branch gets merged to main. Please read more about this topic in release cycles. In summary, there are key words you can add to your commit message that will trigger certain actions.\nFor example, the word bug will trigger the version patch number to increase, meaning if your current codebase is on version v1.0.0 it will increase the version to v1.0.1 . Here’s what it looks like in Github:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe word feat will trigger a change in the minor version, so it will bump v1.0.0 to v1.1.0. There are many other words that can trigger actions and you can customize them to do what you want.\nI strongly recommend implementing this in your repo and working in a release cycle. To give an example, our team has a 1 month release cycle:\n\nweek 1: planning out code changes and fixes\nweek 2: writing out code and making pull requests\nweek 3: reviewing pull requests and testing them\nweek 4: preparing communications about the new changes and merging the code to main\n\nOnce the code is merged to main, we have a github action that automatically creates our versioning, change logs, documentation, and saves a snapshot of our codebase. The action looks for trigger words (like fix, feat or BREAKING CHANGE) and it will divide the commits that were merged into the main branch and write out all the documentation for the change log. It looks like this:\n\n\nNotice that I can:\n\nUse the version numbers as a tag and switch versions of my entire code base. Very useful if something breaks in production and you want to revert to the old code base, and it gives someone the option of downloading a specific version of your package\nI have a summary of all the commits (with links) that were included in that version\nI don’t need to manually do anything\nI can send that change log to leadership and show a high level view of the changes made, with the option to see granular details if wanted\nIt documents all of you conversations and changes (+1 for transparency! ➕)\n\nFor more details, follow the release cycles guide",
    "crumbs": [
      "Github",
      "Policies",
      "Contribution/Collaboration Guide"
    ]
  },
  {
    "objectID": "gh/contribute.html#github-project-management",
    "href": "gh/contribute.html#github-project-management",
    "title": "Contribution/Collaboration Guide",
    "section": "Github project management",
    "text": "Github project management\nMilestones, projects, labels, etc.",
    "crumbs": [
      "Github",
      "Policies",
      "Contribution/Collaboration Guide"
    ]
  },
  {
    "objectID": "gh/how_to.html",
    "href": "gh/how_to.html",
    "title": "Repo Documentation",
    "section": "",
    "text": "This site was created using Quarto, Github, and uses a Github Action to automatically render when a commit is pushed to the main branch of this repository.\nQuarto is a framework for creating documentation, slideshows, articles, blogs, books and websites using markdown. It can execute R, Python and other programming languages within the document.\nGithub Actions uses a .yml file in the repository to trigger an action based on a certain event. In this case, when a commit is pushed to the main branch the .yml will trigger this Quarto website to render to the gh-pages branch of the repository and publish the github page. This section will give details on how to\n\nCreate the website\nCreate, edit, and troubleshoot the Github Action to render the site",
    "crumbs": [
      "Github",
      "Tutorials",
      "Repo Documentation"
    ]
  },
  {
    "objectID": "gh/how_to.html#editadd-sections-and-chapters",
    "href": "gh/how_to.html#editadd-sections-and-chapters",
    "title": "Repo Documentation",
    "section": "Edit/Add Sections and Chapters",
    "text": "Edit/Add Sections and Chapters\nTo add a section, open up the _quarto.yml file and scroll to the navbar section\n\n\n\n_quarto.yml\n\nproject:\n  type: website\nwebsite:\n  title: \"COE Github Standards\"\n  search: true\n  \n  navbar: \n    background: primary\n    left: \n      - text: Home\n        href: index.qmd\n      - text: Github Organization Standards\n        menu: \n          - href: std/security.qmd\n            text: \"0: Security Standards\"\n          - href: std/lic.qmd\n            text: \"1: Choosing a License\"\n          - href: std/templates.qmd\n            text: \"2: Org Policy Setting\"\n\n\n\nThis is where all of the qmd files are sourced and the instructions on how to format and style the navigation bar in the website.\nCurrently, the project is set up to have each section have it’s own drop down menu in the navbar. In a section, use - href: to specify a file and text: to give the file a custom name in the website.\nEach chapter exists within a sub-folder, so to add a chapter make sure create the qmd in its sub-folder and then reference the sub-folder and chapter in the .yml. For example, if you make a new chapter called new-chapter.qmd and it exists in the covid section/sub-folder, you need to reference it in the .yml file like: covid/new-chapter.qmd",
    "crumbs": [
      "Github",
      "Tutorials",
      "Repo Documentation"
    ]
  },
  {
    "objectID": "gh/how_to.html#website-style",
    "href": "gh/how_to.html#website-style",
    "title": "Repo Documentation",
    "section": "Website Style",
    "text": "Website Style\nYou can customize many aspects of the website in the .yml file itself with the format: function. There are a ton of themes included in Quarto here and you can also add a custom css and/or scss file to your project. I think you can even go super in depth and customize the javascript components of the site, but I’m not entirely sure how to do that yet. This website has a ton of custom css components with Quarto, and possibly uses custom javascript, so it could be a place to start if you’re interested. Basically, you need to embed the css file into your _quarto.yml file\n\n\n\n_quarto.yml\n\nformat:\n  html:\n    theme: \n      - cosmo\n      - assets/styles.scss\n    scss: assets/styles.scss\n    # css: styles.css\n    toc: true\n    highlight-style: assets/custom.theme",
    "crumbs": [
      "Github",
      "Tutorials",
      "Repo Documentation"
    ]
  },
  {
    "objectID": "gh/how_to.html#open-the-r-project",
    "href": "gh/how_to.html#open-the-r-project",
    "title": "Repo Documentation",
    "section": "Open the R project",
    "text": "Open the R project\nThis is a Quarto website that is contained in a .rproj file path. The R project contains all the documents used to create this website. Begin by opening the R project when should be in your local clone under C:\\Users\\XXXXXXX\\Projects\\Sequencing_2.0\\sequencing_documentation\\sequencing_documentation.Rproj",
    "crumbs": [
      "Github",
      "Tutorials",
      "Repo Documentation"
    ]
  },
  {
    "objectID": "gh/how_to.html#open-the-files",
    "href": "gh/how_to.html#open-the-files",
    "title": "Repo Documentation",
    "section": "Open the files",
    "text": "Open the files\nThis project has .qmd files (Quarto Markdown files) that each represent a chapter in the website. All of the .qmd files are knitted together (using R knitr) which compiles all of the files to be sourced into htmls.\nThis website is set up to have each major section contain multiple chapters. To open a chapter, the bottom right pane in your R Studio window should contain folders for each section, highlighted below\n\n$ tree /f\nC:.\n│   .gitignore\n│   about.qmd\n│   index.qmd\n│   standards.Rproj\n│   _quarto.yml\n│\n├───assets\n│       custom.theme\n│       styles.css\n│       styles.scss\n│\n├───std\n│   │   creds.qmd\n│   │   lic.qmd\n│   │   public_code.qmd\n│   │   security.qmd\n│   │   templates.qmd\n│   │\n│   └───images\n│\n├───tools\n│   │   how_to.qmd\n│   │   iac.qmd\n│   │   link_code.qmd\n│   │   readme.qmd\n│   │   release.qmd\n│   │   renv.qmd\n│   │   teams.qmd\n│   │\n│   └───images\n\nError in running command bash\n\n\n\nThe .qmd files are inside of these folders. Select one to edit.",
    "crumbs": [
      "Github",
      "Tutorials",
      "Repo Documentation"
    ]
  },
  {
    "objectID": "gh/how_to.html#commit-changes",
    "href": "gh/how_to.html#commit-changes",
    "title": "Repo Documentation",
    "section": "Commit changes",
    "text": "Commit changes\nOnce you’re done editing, push the change to the main branch (or make a new branch, and then a pull request for the main branch). More one this in the git chapter",
    "crumbs": [
      "Github",
      "Tutorials",
      "Repo Documentation"
    ]
  },
  {
    "objectID": "gh/how_to.html#example-yaml-workflow",
    "href": "gh/how_to.html#example-yaml-workflow",
    "title": "Repo Documentation",
    "section": "Example YAML Workflow",
    "text": "Example YAML Workflow\nThe .yml workflow for this project looks something like this:\non: is a tag indicating when the action will run. Right now it will run when any code gets pushed to the main branch in the documentation folder or lineages_public_repo.R script\n\n\n\nquarto-publish.yml\n\non: \n  push:\n    branches:\n      - main\n    paths:\n      - documentation/**\n      - lineages_public_repo.R\n\n\njobs: is a tag that tells a Github virtual machine what to run and what operating system to run it on. In this case ubuntu with the latest version. This can be windows, linux or macOS.\n\n\n\nquarto-publish.yml\n\nname: Render and Publish\n\njobs:\n  build-deploy:\n    runs-on: ubuntu-latest\n\n\n\nNow we have the steps:\n\nenv will find the renv folder\nuses: actions/checkout@v3 will refresh the repo and pull the latest changes\nuses: quarto-dev/quarto-actions/setup@v2 will install quarto\nuses: actions/cache@v1 and the code below it will set up renv and use the cached packages to install them onto the Github virtual machine\n\n\n\n\nquarto-publish.yml\n\n    env:\n      RENV_PATHS_ROOT: ~/.cache/R/renv\n      \n    steps:\n      - name: Check out repository\n        uses: actions/checkout@v3\n        \n      - name: Set up Quarto\n        uses: quarto-dev/quarto-actions/setup@v2\n        \n      - name: Prep CURL install\n        run: sudo apt-get update\n\n      - name: Install CURL Headers\n        run: sudo apt-get install libcurl4-openssl-dev\n\n      # - name: Setup Renv\n      #   uses: r-lib/actions/setup-renv@v2\n  \n      - name: Cache packages\n        uses: actions/cache@v1\n        with:\n          path: ${{ env.RENV_PATHS_ROOT }}\n          key: ${{ runner.os }}-renv-${{ hashFiles('**/renv.lock') }}\n          restore-keys: |\n            ${{ runner.os }}-renv-\n      \n      - name: Restore packages\n        shell: Rscript {0}\n        run: |\n          if (!requireNamespace(\"renv\", quietly = TRUE)) install.packages(\"renv\")\n          renv::restore()\n\n\n\nAnd finally,\n\nuses: quarto-dev/quarto-actions/publish@v2 will render the site by running quarto render\nwith: target: gh-pages path: documentation/_site lets you know which branch and path to render the site to\n\n\n\n\nquarto-publish.yml\n\n      - name: Publish to GitHub Pages (and render)\n        uses: quarto-dev/quarto-actions/publish@v2\n        with:\n          target: gh-pages\n          path: documentation/_site\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # this secret is always available for github actions",
    "crumbs": [
      "Github",
      "Tutorials",
      "Repo Documentation"
    ]
  },
  {
    "objectID": "gh/how_to.html#using-renv-in-the-gh-action",
    "href": "gh/how_to.html#using-renv-in-the-gh-action",
    "title": "Repo Documentation",
    "section": "Using renv in the GH Action",
    "text": "Using renv in the GH Action\nIf you need to constantly update your website with code chunk, this is the best way to do it. It is also probably safer and better than the _freeze way, but it requires a better understanding of Github Actions and virtual environments.\nrenv is an R package for creating a project level virtual environment. In other words, renv will create project specific folders that contain the specific R package versions you use in an project. More on virtual environments here\nTo use renv in a Github Action, you can put\n\n\n\n\nquarto-publish.yml\n\n- name: Setup Renv\n  uses: r-lib/actions/setup-renv@v2\n\n\n\nor use the renv cache code in the yaml section above",
    "crumbs": [
      "Github",
      "Tutorials",
      "Repo Documentation"
    ]
  },
  {
    "objectID": "gh/how_to.html#using-a-_freeze-file",
    "href": "gh/how_to.html#using-a-_freeze-file",
    "title": "Repo Documentation",
    "section": "Using a _freeze file",
    "text": "Using a _freeze file\nIf you only need to execute the code once or just need to render a non-executable code chunk once, make sure you have this code in your _quarto.yml file:\n\n\n\n\n_quarto.yml\n\nexecute:\n  error: true\n  freeze: true\n\n\n\nand then run this in your terminal window:\nquarto render name-of-specific-document-or-chapter.qmd\nThis will render that specific document in the website, execute code chunks if they are set to execute (eval: true) and then it will create a _freeze file. The _freeze file will save a snapshot of that specific document and not re-render it in the Github Action. This means you can render other parts of the website, but any files in the _freeze folder will stay the same as they are in the freeze. If you need to make changes to a freeze document, run the quarto render code again after making changes.\nThis is also documented in the Quarto dev documentation",
    "crumbs": [
      "Github",
      "Tutorials",
      "Repo Documentation"
    ]
  },
  {
    "objectID": "gh/how_to.html#troubleshooting",
    "href": "gh/how_to.html#troubleshooting",
    "title": "Repo Documentation",
    "section": "Troubleshooting",
    "text": "Troubleshooting\nSo you did these steps:\n\nCreate the quarto-publish.yml\nRun quarto publish gh-pages in the terminal\nPush all the files in your git to the main branch\n\nIf this works on your first try then the universe is taking extra special care of you.\nIf not, you are like the rest of us poor souls:/\n\nThe first thing I would check is the error in your Github repo’s Action tab.\nIf the error is something like jsonlite not installed or some package not installed then it most likely means your are trying to commit a chunk of code in the documentation. Even if you are not executing the code, Github Actions will punish you. There are a couple options to fix this, depending on your priorities.\n\nIf you don’t care about executing your code and/or only need to push that part of the script once, consider using the _freeze option\nIf you need to execute code or need to programmtically render the document with code chunks often, consider using renv or a similar package installation method",
    "crumbs": [
      "Github",
      "Tutorials",
      "Repo Documentation"
    ]
  },
  {
    "objectID": "gh/renv.html",
    "href": "gh/renv.html",
    "title": "Virtual Environments",
    "section": "",
    "text": "Virtual environments allow us to execute code while accounting for software/package version differences we have on our local machines. This repo uses virtual environments to configure a user’s R and Python software and packages to the repo’s specific package versions.\nFor example, say you have dplyr version 2.0 but this repo uses dplyr version 1.1, you may not be able to run the scripts as intended by the author since the functions in dplyr 1.1 may be different than in 2.0. The virtual environment will allow a given user to use only this repo’s version of dplyr so they can run the code as intended.\n\n\n\n\n\n\nImportant\n\n\n\nThere are two different virtual environments for this repo, one for R and another for Python. Your workflows for opening R and Python and how you install packages needs to utilize the virtual environments so that all machines are able to use your code.",
    "crumbs": [
      "Github",
      "Tutorials",
      "Virtual Environments"
    ]
  },
  {
    "objectID": "gh/renv.html#step-1-set-up-anaconda",
    "href": "gh/renv.html#step-1-set-up-anaconda",
    "title": "Virtual Environments",
    "section": "Step 1: Set Up Anaconda",
    "text": "Step 1: Set Up Anaconda\nYou should already have Anaconda installed on your machine if not..\nunder construction",
    "crumbs": [
      "Github",
      "Tutorials",
      "Virtual Environments"
    ]
  },
  {
    "objectID": "gh/renv.html#step-2-open-anaconda-prompt",
    "href": "gh/renv.html#step-2-open-anaconda-prompt",
    "title": "Virtual Environments",
    "section": "Step 2: Open Anaconda Prompt",
    "text": "Step 2: Open Anaconda Prompt\nYou may have different Anaconda prompts (prompts aligned with different shells, like PowerShell, bash, etc). There should be a generic Anaconda prompt. Open that one:\n\n\nIf the first line in the prompt doesn’t start with (base), write:\nconda deactivate\nand it will bring you back to your base environment.",
    "crumbs": [
      "Github",
      "Tutorials",
      "Virtual Environments"
    ]
  },
  {
    "objectID": "gh/renv.html#step-3-change-directories",
    "href": "gh/renv.html#step-3-change-directories",
    "title": "Virtual Environments",
    "section": "Step 3: Change Directories",
    "text": "Step 3: Change Directories\nChange the directory of the prompt to the repo’s directory. The code is\ncd C:/Users/XXXXXXX/Projects/Sequencing_2.0\nIf you are already in your user directory, you can just type\ncd projects/sequencing_2.0\ncapitalization doesn’t matter\n\n\nNotice that the folder path is now changed to the sequencing repo folder.",
    "crumbs": [
      "Github",
      "Tutorials",
      "Virtual Environments"
    ]
  },
  {
    "objectID": "gh/renv.html#step-4-copy-the-repo-env",
    "href": "gh/renv.html#step-4-copy-the-repo-env",
    "title": "Virtual Environments",
    "section": "Step 4: Copy the repo env",
    "text": "Step 4: Copy the repo env\nNow we’re ready to create a new environment based on the repo’s environment.\nType: conda env create --name seq_env --file=environment.yml\nNote that how you name your environment doesn’t really matter, but name it something that resembles the repo. This will save the headache of having random environments for random repos that you can’t remember..\n\n\nconda env create will create a new environment in your C:/Users/XXXXX/Anaconda3/envs file path\n--name or -n will name that environment, in this case seq_env\n--file=environment.yml this code will take the file in the sequencing 2.0 repo and use it to create this environment. It is essentially a copy of the software versions in the file.\n\nNote: I sped up the gif below. The whole process may take a few minutes",
    "crumbs": [
      "Github",
      "Tutorials",
      "Virtual Environments"
    ]
  },
  {
    "objectID": "gh/renv.html#step-5-activate-the-environment",
    "href": "gh/renv.html#step-5-activate-the-environment",
    "title": "Virtual Environments",
    "section": "Step 5: Activate the environment",
    "text": "Step 5: Activate the environment\nYou can switch between environments in the conda prompt or in a programming IDE (or both? idk). To activate and switch the env, write:\nconda activate &lt;env_name&gt;\nin this case\nconda activate seq_env\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe environment your in will show on the left of the prompt message. In this case it says (seq_env) instead of (base). That way you know what env your working in",
    "crumbs": [
      "Github",
      "Tutorials",
      "Virtual Environments"
    ]
  },
  {
    "objectID": "gh/renv.html#ide-setup---vs-code",
    "href": "gh/renv.html#ide-setup---vs-code",
    "title": "Virtual Environments",
    "section": "IDE Setup - VS Code",
    "text": "IDE Setup - VS Code\nVS Code has a lot built in to use a conda environment. Since your env is already activated, if you have VS Code installed, you can type\ncode\ninto the anaconda prompt and it will open a VS Code window\n\n\nStep 1: Select a Python Interpreter\nFirst we need to select a python interpreter, which is in our env. On your keyboard, press\nCTRL+SHIFT+P\nThis should bring up a window with an option that says Python: Select Interpreter. You may need to search for it.\nClick it and you should see your new environment seq_env in the list. Click it\n\n\n\nStep 2: Write code\nNow your VS Code is using your environment and the python version/packages in that environment. Check to see that your terminal is using the correct env.\nOpen the terminal (terminal &gt; new terminal) and confirm that you are in a cmd prompt in the terminal. On the right side of the terminal it should say cmd. If it says powershell or something else, let’s change it.. See the pic below. There’s a drop down that gives you shell types. Change your default to Command Prompt\n\n\nAlso notice in the picture that my environment now switches to seq_env. Yours should do the same. You should now be able to run code in a python script. Notice that your terminal will change to run python. If you get an error, write python in the terminal and hit enter. It will change your terminal a little. Now you can run python code and it will output to this terminal.",
    "crumbs": [
      "Github",
      "Tutorials",
      "Virtual Environments"
    ]
  },
  {
    "objectID": "gh/renv.html#ide-setup---pycharm",
    "href": "gh/renv.html#ide-setup---pycharm",
    "title": "Virtual Environments",
    "section": "IDE Setup - PyCharm",
    "text": "IDE Setup - PyCharm\nPyCharm also works great with a conda environment.\n\nStep 1: Select a Python Interpreter\nYou may also be able to open a PyCharm window from an Anaconda prompt like with VS Code (if it’s installed in your env). To do so, write pycharm in the prompt and it should open a new window with the env activated.\nIf that doesn’t work, open PyCharm and on the bottom right there is a python version and interpreter selected. Click it and open “Add New Interpreter” &gt; “Add local interpreter”. This opens a new window. Click “Conda Environment” and under “Interpreter” click the dropdown. You should be able to see your new environment there. If not, click away and click the dropdown again. It’s weird sometimes.\nThen click okay. Close and reopen the Python Console window and it should have your environment path for the python.exe. Also, the Python Libraries window should have all of the libraries in your environment now.\n\n\nNotice that now there are a list of interpreters for you to use. You can now switch back and forth between environments. This is great if you have other repos to use or want to test out new packages that aren’t in the main environment.",
    "crumbs": [
      "Github",
      "Tutorials",
      "Virtual Environments"
    ]
  },
  {
    "objectID": "gh/renv.html#step-1-install-a-new-package",
    "href": "gh/renv.html#step-1-install-a-new-package",
    "title": "Virtual Environments",
    "section": "Step 1: Install a new package",
    "text": "Step 1: Install a new package\nGo to the Anaconda prompt, make sure you’re in the repo file path (cd projects/sequencing_2.0) and make sure you’re in the right conda env (conda activate seq_env).\nNow, install the package. Usually packages can be installed with pip install or conda install or conda install -c conda forge &lt;package&gt;. This depends on the packages. Some need pip, others need conda. Google it to find out. Here i’m going to download a package from NCBI to demonstrate. The package is called ncbi-datasets-cli.\n\nThis package uses conda-forge to install. Type in conda install -c conda-forge ncbi-datasets-cli\nIt will give you a message Y/N to confirm. Type “y” and enter",
    "crumbs": [
      "Github",
      "Tutorials",
      "Virtual Environments"
    ]
  },
  {
    "objectID": "gh/renv.html#step-2-save-the-package-to-the-repo",
    "href": "gh/renv.html#step-2-save-the-package-to-the-repo",
    "title": "Virtual Environments",
    "section": "Step 2: Save the package to the repo",
    "text": "Step 2: Save the package to the repo\nNow we need to save this package to the repo’s environment.yml\n\nType conda env export &gt; environment.yml\nSince the package is in your environment, this code is exporting your new environment to repo’s one.\nNow push to github",
    "crumbs": [
      "Github",
      "Tutorials",
      "Virtual Environments"
    ]
  },
  {
    "objectID": "gh/renv.html#creating-renv-in-a-project",
    "href": "gh/renv.html#creating-renv-in-a-project",
    "title": "Virtual Environments",
    "section": "Creating renv in a project",
    "text": "Creating renv in a project\n\nStep 1: Open the .Rproj in your repo\nThe R project will open up Rstudio at the root of you directory path.\n\n\n\nStep 2: Initialize renv for the repo\nNow that we’re in the root of your repo directory, let’s initialize renv.\nFirst install renv - install.packages(\"renv\")\nThen in your console write renv::init() and run it.\n\nIf you already have an existing repo, you will probably see warnings and errors in the renv::init like I did in the gif above. Not to worry! Read the warnings and follow the instructions. Usually you will need to re-install a package. If you get this warning:\nThese may be left over from a prior, failed installation attempt.\nConsider removing or reinstalling these packages.\n\nThen run renv::install(\"THAT PACKAGE\"). It will install the package again,\nand then you need to update the lock file (more on that later) by running renv::snapshot().\n\nNow the package will be installed correctly\n\nrenv::init() will:\n\nSearch through all R scripts in your repo and find all packages used\nCreate a snapshot of those packages\nSave all packages in the repo in a new renv libraries path (similar to your C drive R libraries paths)\nCreate a .gitignore within the renv libraries path so that you don’t get spammed with thousands of libraries in your git commit\nCreate a lock file - this is like the environment.yml for conda. Think of it as instructions for which packages your repo is using\nIt also saved things like an activate R script which will activate that renv every time the repo is opened from the .Rproj\n\n\n\nStep 3: Push to Github\nNow look at your git stage and you will see all the files renv created.\nWe have\n\n.Rprofile that contains an renv activate.R script - this will activate the repo’s renv every time the project is opened\nThe renv.lock file shows information on each package used in the repo and is used to update collaborator’s environments to match the lock file.\nrenv/.gitignore I don’t feel like explaining this one right now - i’ll write more later\nrenv/activate.R this will activate the env whenever the R project is opened\nrenv/settings.dcf I have no clue what this is",
    "crumbs": [
      "Github",
      "Tutorials",
      "Virtual Environments"
    ]
  },
  {
    "objectID": "gh/renv.html#using-renv-in-a-project",
    "href": "gh/renv.html#using-renv-in-a-project",
    "title": "Virtual Environments",
    "section": "Using renv in a project",
    "text": "Using renv in a project\n\nStep 1: Open the .Rproj for your repo\nAny time you need to code or run code from the repo, open up the .Rproj file that contains the sequencing 2.0 project. In your file explorer, go to the repo and open Sequencing_2.0 .Rproj\n\nThis will open up an R window with the repo file path as a root directory. It will also utilize the renv. Your console should say something about renv, like this\n\n\n\nStep 2: Load renv packages\nThe first time you use renv you will need to configure it to your local machine. To do this, type:\n\nrenv::restore() in your console.\nThis will create a new environment for your R in your local machine using the lock file packages.\n\n\nNow you’re ready to use the scripts! Way less complicated than conda",
    "crumbs": [
      "Github",
      "Tutorials",
      "Virtual Environments"
    ]
  },
  {
    "objectID": "gh/codespaces.html",
    "href": "gh/codespaces.html",
    "title": "NW-COE Policies",
    "section": "",
    "text": "title: “Github Codespaces” description: How to use Github Codespaces for reproducibility/data democratization date: February 1, 2023 date-modified: today author: Frank Aragona # categories: # - data democratization # - docker # - Github # - reproducibility # —"
  },
  {
    "objectID": "gh/lic.html",
    "href": "gh/lic.html",
    "title": "Licensing",
    "section": "",
    "text": "Summary\n\nLicenses prevent code theft and inappropriate redistribution of code.\nReview common open-source licenses\nLicense types vary depending on repo goals\n\n\n\n\nGeneral License Info\nBelow is a list of common open-source licenses.\n\n\nThere isn’t a one size fits all license, so thankfully there are a variety of options. Here are two common ones:\n\n\nGNU GPL licenses\n\nThese are the strong licenses\nPrevents someone from taking our code and privatizing it (and making money off of it)\nSomeone can still use our code, they just need to ensure that what they’re doing with it is open-source\n“Copyright and license notices must be preserved.”\n“Contributors provide an express grant of patent rights. When a modified version is used to provide a service over a network, the complete source code of the modified version must be made available.”\n\n\n\nMIT license\n\nI think this is the most commonly used one\n“short and simple permissive license… only requiring preservation of copyright and license notices”\n“Licensed works, modifications, and larger works may be distributed under different terms and without source code.”\nSomeone could basically do whatever they want with the code.\nNextstain/ncov repo is currently using this\n\nAnd here are a couple of youtube videos that were helping in explaining licensing",
    "crumbs": [
      "Github",
      "Policies",
      "Licensing"
    ]
  },
  {
    "objectID": "gh/security.html",
    "href": "gh/security.html",
    "title": "Repo Security",
    "section": "",
    "text": "Objectives\n\nPrevent sensitive information leaks to Github\nSet up guardrails, .gitignore, hooks\nScrub private repos before they go public\nIf sensitive information is leaked and commited to the remote repo, then they will stay in the git history (and will require a lot of effort to remove them from the history). The following cannot be included in any repo or any local commit!:",
    "crumbs": [
      "Github",
      "Policies",
      "Repo Security"
    ]
  },
  {
    "objectID": "gh/security.html#environment-variables-.gitignore",
    "href": "gh/security.html#environment-variables-.gitignore",
    "title": "Repo Security",
    "section": "Environment Variables + .gitignore",
    "text": "Environment Variables + .gitignore\nWe can store private information in local files and make sure that the do not get pushed to the public remote repo by using .gitignore. There are a number of ways to do this. We typically use a yaml file that can be filled out with personal credentials locally. The file will not be committed to the remote repo.\nThere are many ways to achieve this. If you have a more simple workflow that uses R, consider the .Renviron approach. If you have a more complex workflow that has multiple languages and many credentials, consider the yaml approach\n\n.Renvironyaml\n\n\nIf you’re using just R in your repo and have just a few things you want private, consider using a .Renviron file in addition to .gitignore.\n\nIn the .gitignore, add .Renviron:\n\n\n\n\n.gitignore\n\n# R Environment Variables\n.Renviron\n\n\n\nCreate a .Renviron file at the root of you local repo\nAdd the things you want to be kept private\n\n\n\n\n.Renviron\n\nmy_password=\"thisismypassword123\"\n\n\n\nNow in an R script you can call that password and hide the credentials instead of writting the password in the script for everyone to see:\n\n\n\n\n\n\ngood_script.R\n\nmy_password &lt;- Sys.getenv('my_password')\n\n\n\n\n\n\n\nbad_script.R\n\nmy_password &lt;- \"thisismypassword123\"\n\n\n\n\nSys.getenv() looks for the .Renviron file and the variables inside of it. This means you can get all your credentials from the .Renviron but also keep that information\n\n\nHere’s another way to add credentials that may be more robust.\nMany of our scripts use a .yml file that contains a list of API tokens, server names, and usernames/passwords specific to each individual user. There are two .yml files. One is a template (containing no actual passwords..) that exists in the repo and serves as a template so every individual user can keep up to date with new credential additions. The other is the individual creds.yml that is in the repo’s .gitignore. This file will never exist in the repo and only exist locally (in the user’s C drive).\nThe .yml file can work with multiple programming languages including R and Python. They are read in the same way and can be easily adjusted when adding new passwords or using them as configuration files. It can work like this:\n\nIn your .gitignore, add a new line that says creds.yml.\n\n\n\n\n\n.gitignore\n\n# creds files\ncreds.yml\n\n\n\n\nIn the root of you local git clone, make a file called creds.yml.\nIn the yaml file you can nest values. For example, under conn_list_wdrs I have all the parameters needed to make a SQL server connection string in R/Python:\n\n\n\n\ncreds.yml\n\n# Default is needed to distinguish values.\n# Leave a blank line (NO SPACES) as the last line in this file or things will break\n# Quotes aren't necessary, but can be used.\ndefault: \n  conn_list_wdrs:\n    Driver: \"SQL Server Native Client 11.0\"\n    Server: \"someservername\"\n    Database: \"db\"\n    Trusted_connection: \"yes\" \n    ApplicationIntent: \"readonly\"\n    \n  fulgent:\n    username: &lt;USERNAME&gt;\n    password: &lt;PASSWORD&gt;\n\n\n\nTo call these credentials in R or Python it will look like this:\n\n\n\n\n\n\nscript.R\n\nlibrary(yaml)\n\n# read in the local credentials yaml file\ncreds &lt;- yaml::read_yaml(\"creds.yml\")$default\n\n# call in the variables\n\nconnection &lt;- DBI::dbConnect(\n  odbc::odbc(), \n  Driver = creds$conn_list_wdrs$Driver, \n  Server = creds$conn_list_wdrs$Server, \n  Database = creds$conn_list_wdrs$Database, \n  Trusted_connection = creds$conn_list_wdrs$Trusted_connection, \n  ApplicationIntent = creds$conn_list_wdrs$ApplicationIntent\n)\n\n\n\n\n\n\n\nscript.py\n\nimport yaml\n\n# read credentials\nwith open(f\"creds.yml\") as f:\n    creds = yaml.safe_load(f)['default']\n\nconn = pyodbc.connect(\n  DRIVER=creds['conn_list_wdrs']['Driver'],\n  SERVER=creds['conn_list_wdrs']['Server'],\n  DATABASE=creds['conn_list_wdrs']['Database'],\n  Trusted_Connection=creds['conn_list_wdrs']['Trusted_connection'],\n  ApplicationIntent=creds['conn_list_wdrs']['ApplicationIntent']\n  )\n\n\n\n\n\nYou can add more nested sections besides default, like this, where I added a test parameter:\n\n\n\n\ncreds.yml\n\n# Default is needed to distinguish values.\n# Leave a blank line (NO SPACES) as the last line in this file or things will break\n# Quotes aren't necessary, but can be used.\ndefault: \n  conn_list_wdrs:\n    Driver: \"SQL Server Native Client 11.0\"\n    Server: \"someservername\"\n    Database: \"db\"\n    Trusted_connection: \"yes\" \n    ApplicationIntent: \"readonly\"\n    \n  fulgent:\n    username: &lt;USERNAME&gt;\n    password: &lt;PASSWORD&gt;\n\ntest:\n  conn_list_wdrs:\n    Driver: \"SQL Server Native Client 11.0\"\n    Server: \n    Database: \n    Trusted_connection: \n    ApplicationIntent: \n\n\nThis is useful to organized and automatically call different parameters. Now there is a test list with its own variables. This lets us switch a set of variables within our scripts. default applies to the main credentials where test can distinguish which variables should be test or dev scripts specific. Notice below that you can now call the credentials from a .yml file into an R or Python script and the actual credentials will never exist in the code pushed to the repo.\n\n\n\nscript-in-repo.R\n\n# this script is in the repo, but credentials are hidden\nlibrary(yaml)\n\n# read in the local credentials yaml file\ncreds &lt;- yaml::read_yaml(\"path/to/local-credentials.yml\")\n\n# pull in the credentials\nserver_name &lt;- creds$default$conn_list_wdrs$server\n\n\n\nAutomating With Yaml Creds\nWe can even get more specific and add an if-else statement to specify which credential we want to select. This can be helpful if we have a CI/CD pipeline and have a script automatically run on a task scheduler or cron job. We can call the credentials we want in the command line and have the command line code run in my task scheduler. That way we can use multiple different versions of the same script and have all of it be automated.\nFor example,\n\nthe R script on the left uses the commandArgs() to pull any arguments passed to the script in a shell/command line script.\non the right, the shell script has production and test as second arguments.\nthese are passed to the R script as arg[2].\nnow we can use arg[2] in the if-else statement to conditionally select credentials and do it automatically in a pipeline.\n\n\n\n\n\n\nscript-in-repo.R\n\nargs &lt;- commandArgs(TRUE)\n\n# this script is in the repo, but credentials are hidden\nlibrary(yaml)\n\n# read in the local credentials yaml file\ncreds &lt;- yaml::read_yaml(\"path/to/local-credentials.yml\")\n\n# pull in the credentials\nif(args[2] == \"production\"){\n  server_name &lt;- creds$default$conn_list_wdrs$server\n} else if(args[2] == \"test\"){\n  server_name &lt;- creds$test$conn_list_wdrs$server\n}\n\n\n\n\n\n\n\nshell-trigger-script.sh\n\n# Run the production code\n$ Rscript -e \"source('path/script_in_repo.R');\" production\n\n# Run the test/dev code\n$ Rscript -e \"source('path/script_in_repo.R');\" test \n\n\n\n\n\n\nyaml Template\nYou can put a template creds.yml file in your repo so that others can see what credentials they need in order for the code to run.\nThis is a template file, so it will not have any passwords/secrets in it. Its only purpose is to provide an example copy of what a user’s creds.yml file needs to look like.\n\nMake a template called creds_TEMPLATE.yml\nRemove any passwords, usernames, secrets, etc to have it be a file that looks like this:\n\n\n\n\ncreds_TEMPLATE.yml\n\n# Default is needed to distinguish values.\n# Leave a blank line (NO SPACES) as the last line in this file or things will break\n# Quotes aren't necessary, but can be used.\ndefault: \n  conn_list_wdrs:\n    Driver: \n    Server: \n    Database: \n    Trusted_connection: \n    ApplicationIntent: \n    \n  fulgent:\n    username: \n    password: \n\ntest:\n  conn_list_wdrs:\n    Driver: \n    Server: \n    Database: \n    Trusted_connection: \n    ApplicationIntent: \n\n\n\nOnce you have the creds_TEMPLATE.yml template in your repo, make sure that nobody on your team (or anyone with write access..) is able to accidentally push changes to the template. We don’t want someone’s passwords or API tokens to exist in GitHub.\n\nThis link shows how to skip any changes made to the specific file https://stackoverflow.com/a/39776107. If someone makes local changes to the template, the changes will not show in their commit. It is a safe guard.\n\nFor all individual users, run this code:\n\n\n\n\nPowerShell\n\ngit update-index --skip-worktree creds_TEMPLATE.yml\n\n\n\n\nThis will tell your local git to ignore any changes made to creds_TEMPLATE.yml, but also allow it to exist in the repo (since .gitignore will prevent it from being in the repo)\n\nIf you need to update the template file run this:\n\n\n\n\nPowerShell\n\ngit update-index --no-skip-worktree creds_TEMPLATE.yml\n\n\n\n\nThis will allow changes to the template. So when you need to update the template, use this code\nAnd to get a list of files that are “skipped”, use this code:\n\n\n\n\nPowerShell\n\ngit ls-files -v . | grep ^S",
    "crumbs": [
      "Github",
      "Policies",
      "Repo Security"
    ]
  },
  {
    "objectID": "gh/security.html#instructions",
    "href": "gh/security.html#instructions",
    "title": "Repo Security",
    "section": "Instructions",
    "text": "Instructions\n\nCheck that the secrets_key regex is working by running the process on a repo that you know has secrets in it. For example, in a different folder, run all the pre-commit hook steps above and add a known “bad” string into the regex. For example, in the regex put bad_string and in a file in that folder put bad_string. When you scan it should get flagged.\nIf secret scanning is taking too long, you might want to check certain files first. I’ve found that HTML files take a very long time to scan for secrets.\n\nFollow the instructions below to scan for specific files. The script will scan for all the file types that you select. For example, if you want to only scan R files, it will only scan R files.\n\nWindowsWSL/Linux\n\n\n\nIn PowerShell, navigate to your repo and paste this code:\n\n\n\n\nsecret-scanner9000.ps1\n\n# Example Usage\n# write this in the powershell terminal, adjust for the file type(s) you want to scan - can be multiple types: $fileExtensions = @(\".R\", \".py\")\n# then execute this in the terminal: ScanFiles -FileExtensions $fileExtensions\n\n# It will give you an output of any secrets that are contained in those files\n\nFunction ScanFiles{\n  param (\n      [string]$filePath = (Get-Location).Path,\n      [string[]]$fileExtensions\n) \n  Get-ChildItem $filePath -recurse | Where-Object {$_.extension -in $fileExtensions} | \n  Foreach-Object {\n\n      git secrets --scan $_.FullName\n\n  }\n}\n\n\n\nWrite the file extensions you want to scan for in a PowerShell Terminal window like this:\n\n\n\n\nPowerShell\n\n$fileExtensions = @(\".R\",\".py\",\".Rmd\",\".qmd\")\n\n\n\nNow, you can scan your secrets by copying and pasting this code into PowerShell:\n\n\n\n\nPowerShell\n\nScanFiles -FileExtensions $fileExtensions\n\n\n\n\n\nIn a bash/Ubuntu terminal, navigate to your repo and paste this code:\n\n\n\n\nbash\n\nfind . -type f \\( -name \"*.R\" -o -name \"*.py\" -o -name \"*.qmd\" -o -name \"*.rmd\" -o -name \"*.md\" \\) -print0 | xargs -0 -I {} git secrets --scan {}\n\n\n\nThis is set to scan all R, Python, QMD, RMD, or MD files. If you want to add another file type, do it like this where you add -o -name \"*.NEW_TYPE\" to the find command args:\n\n\nfind . -type f \\( -name \"*.R\" -o -name \"*.py\" -o -name \"*.qmd\" -o -name \"*.rmd\" -o -name \"*.md\" -o -name \"*.NEW_TYPE\"  \\) -print0 | xargs -0 -I {} git secrets --scan {}",
    "crumbs": [
      "Github",
      "Policies",
      "Repo Security"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This site was made with Quarto. It can execute code and render the outputs into the html."
  },
  {
    "objectID": "gh/git.html",
    "href": "gh/git.html",
    "title": "Git",
    "section": "",
    "text": "Intro\nShowing how to create and work off of a feature branch using git and github.\n\n\nBefore writing code\nFirst check to see if your main branch is up to date and has the most recent commits added. This should be the first thing you do before running/writing any code.\ngit status will tell you:\n\nWhich branch you are in\nIf your local branch is up to date when comparing to that branch in the remote repo\nIf you have any files waiting to be committed\n\ngit fetch will:\n\nRefresh your branch\nSearch for any differences between your local clone and the repo in github. If there are changes, it will display a message\n\ngit pull will pull all the changes in the remote repo into your local clone branch\n \n\ngit status\n\nError in running command C:/Users/FAA3303/new_git/Git/bin/bash.exe\n\n\n \n\ngit fetch\n\nError in running command C:/Users/FAA3303/new_git/Git/bin/bash.exe\n\n\n \n\ngit pull\n\nError in running command C:/Users/FAA3303/new_git/Git/bin/bash.exe\n\n\nIt’s the same in the git desktop app. Make sure you are in the branch you want to be in, then click fetch and pull to update that branch to include the most recent commits in the remote repo\n\n\n\nSwitch to feature branch\nIf we want to make changes to code, first make a new branch off the main.\ngit branch will show all the branches in the repo and the one you are currently in\ngit checkout -b new-branch-name will create a new branch. In this case, we already have our feature branch called test-dcipher-cases\ngit checkout branch-name will switch to a branch. In this case we can switch to test-dcipher-cases\n\ngit branch\n\nError in running command C:/Users/FAA3303/new_git/Git/bin/bash.exe\n\n\n\ngit checkout test-dcipher-cases\n\nOr in the desktop app\n\n\n\nMaking changes\nIf we want to make a change to the code, make a new branch off of test-dcipher-cases and switch to that branch\n\n\ngit checkout -b test-frank2\n\n\nand in the desktop app:\n\n\n\n\nCommitting changes to the feature branch\nNow you can make changes in your R script and when you save them they will be ready to be committed to this new branch.\ngit add to stage your changes\ngit commit -am \"messge\" to commit those changes to the new branch with a message\ngit push --set-upstream origin test-dcipher-cases to push those changes to the remote repo on the new branch\n\ngit add\n\ngit commit -am \"this is a test- pls delete\"\n\ngit push --set-upstream origin test-dcipher-cases\n\n\n\n\n\nMaking a pull request\nThis part happens in github.\n\nSelect who you want to review your code and assign yourself.\nUse labels to tag what this pull request refers to (very helpful in search for changes when managing the project) and\nAdd a milestone if it applies.\n\nThis should automatically send an email to the reviewers that there is code needed to be merged to a branch.\n\n\n\nFor Reviewers\nWhen reviewing changes, make sure the commit/changes are being merged to the correct branch.\nGithub automatically compares to the main branch, so you will have to manually click on the base branch and change it to test-dcipher-cases",
    "crumbs": [
      "Github",
      "Tutorials",
      "Git Basics"
    ]
  },
  {
    "objectID": "gh/quickstart.html",
    "href": "gh/quickstart.html",
    "title": "Quickstart - Create a Public Repo",
    "section": "",
    "text": "If you need to make a public repo, this guide is for you. It is a quick start on what steps you need to take, as well as links to further documentation that I highly recommend going through. Please meet with Frank Aragona frank.aragona@doh.wa.gov before creating a public repo.\n\nGet access to make a public repo\nGithub Security\nConvert an existing private repo into a public repo\nLicensing\n\n\nAccess\nOur organization has multiple public Github orgs. If you are internal to Washington Department of Health, you will need to submit a Service Central Request for access. Please reach out to frank.aragona@doh.wa.gov for help.\n\n\nGithub Security\nPlease read all of the security guidelines here\nThe guide will go over\n\nwhat data/code is not allowed in a public repo\nsecurity layers you need to prevent leaks\nconverting private code to public repositories\ninstallation of pre-commit hooks to prevent leaks\n\n\n\nBuilding a Public Repo based on a Private Repo\nIf you have an existing private repo that needs to be public, please follow these steps:\n\nrepo cleaning guides\ncode scanning\n\n\n\nLicensing\n\nlicense rules\n\n\n\nRepo tips/advice\n\norg policies\nmake your repo reproducible\nrepo documentation\nvirtual environments\ngit/github help, and how to collaborate on a repo",
    "crumbs": [
      "Github",
      "Policies",
      "Quickstart - Create a Public Repo"
    ]
  },
  {
    "objectID": "gh/policies.html",
    "href": "gh/policies.html",
    "title": "Org Policies",
    "section": "",
    "text": "Objectives\n\nEnsure that all repos in the org have the required documents\nSet policy rules at the Organization level\nRepos need to have reproducible code\nRepos need to have documentation\nIn the Github Organization we may require all repositories to contain certain documents. For example, we want to make sure that every repo has a CODE OF CONDUCT document that is a general policy applied throughout the organization.\nHere’s a list of required documents:",
    "crumbs": [
      "Github",
      "Policies",
      "Org Policies"
    ]
  },
  {
    "objectID": "gh/policies.html#readme",
    "href": "gh/policies.html#readme",
    "title": "Org Policies",
    "section": "README",
    "text": "README\nREADME files are instructions or documentation on how to use your software. It should give a quick introduction to the repo and instructions on how to install or run the code.",
    "crumbs": [
      "Github",
      "Policies",
      "Org Policies"
    ]
  },
  {
    "objectID": "gh/policies.html#code_of_conduct",
    "href": "gh/policies.html#code_of_conduct",
    "title": "Org Policies",
    "section": "CODE_OF_CONDUCT",
    "text": "CODE_OF_CONDUCT\nA Code of Conduct can let a user know what the rules of the organization are and how any wrongful behavior will be addressed. The document will provide the “standards for how to engage in a community”",
    "crumbs": [
      "Github",
      "Policies",
      "Org Policies"
    ]
  },
  {
    "objectID": "gh/policies.html#contributing.md",
    "href": "gh/policies.html#contributing.md",
    "title": "Org Policies",
    "section": "CONTRIBUTING.md",
    "text": "CONTRIBUTING.md\nThis file should appear in the issue tab in a repo. It lets a user know how they can contribute to the project and if they need to sign any forms before contributing. Some larger organizations require that a person knows what they are contributing to and they must sign a form acknowledging that any software/code contributions to the project will be used and cannot be retracted by the user. The code submitted may also be used to develop processes but the organization will not pay the individual contributor (since this is open-source, we only look for open-source contributions)",
    "crumbs": [
      "Github",
      "Policies",
      "Org Policies"
    ]
  },
  {
    "objectID": "gh/policies.html#license",
    "href": "gh/policies.html#license",
    "title": "Org Policies",
    "section": "LICENSE",
    "text": "LICENSE\nThese should be and are set at the repo level. There will be many different licenses to choose from that will depend on the specific repo. More on that here.",
    "crumbs": [
      "Github",
      "Policies",
      "Org Policies"
    ]
  },
  {
    "objectID": "gh/policies.html#document-requirements-with-.github-repos",
    "href": "gh/policies.html#document-requirements-with-.github-repos",
    "title": "Org Policies",
    "section": "Document Requirements with .github Repos",
    "text": "Document Requirements with .github Repos\nYou can set most policy rules and create documents for each repo at the organization level by using a special .github repo. Dot files and dot folders have special functionality in some software. For Github, the .github folder defines workflows for things like Github Actions in a repo. A .github repository on the other hand defines organization level rules and templates.\n\nIn order to write and set these policies at the organization level we can put them at the root of the .github repository and edit them there.\n\n\n\n\nPowerShell\n\n$ tree /f\nC:.\n│   .gitignore\n│   CODE_OF_CONDUCT.md\n│   CONTRIBUTING.md\n│   LICENSE\n│   README.md\n│\n├───.github\n└───profile\n        README.md\n\n\n\nTake a look above. I have the required documents/policies at the root of the .github repo directory. Now if I open up any given repo in the organization I will find a link to those files:\n\nIf you click on the CODE_OF_CONDUCT link it will take you right to the .github repo and open the CODE_OF_CONDUCT.md file there:\n\nNow you can set organization level policies from the .github repo and they will automatically populate in all existing and new repositories unless there are repo specific policies in place. If a repo already has its own policies they will not be overwritten.",
    "crumbs": [
      "Github",
      "Policies",
      "Org Policies"
    ]
  },
  {
    "objectID": "gh/policies.html#commit-sign-off-requirement---github-apps",
    "href": "gh/policies.html#commit-sign-off-requirement---github-apps",
    "title": "Org Policies",
    "section": "Commit Sign-Off Requirement - Github Apps",
    "text": "Commit Sign-Off Requirement - Github Apps\nWe may want to require authors or reviewers to sign-off on commits to a repo. This is sometimes established in projects to “ensure that copyrighted code not released under an appropriate free software (open source) license is not included in the kernel.”\nYou can install a Github App in the organization and it will be applied to all repos. The DCO App (Developer Certificate of Origin) is popular and lightweight. To install it in the organization, click on Configure and it will give you the option to configure it with the organization of choice.",
    "crumbs": [
      "Github",
      "Policies",
      "Org Policies"
    ]
  },
  {
    "objectID": "gh/templates.html",
    "href": "gh/templates.html",
    "title": "Templates",
    "section": "",
    "text": "This is a Github repo template for R projects. It has renv set up and a .devcontainer for reproducibility\n\n\n\nSelect Use Template &gt; NW-PaGe/R_template when creating a new repo in the NW-PaGe org. The template comes with a pre-filled README.md file that you can edit to your own needs. It’s recommended to leave the .devconainter folder in this repo. It serves as instructions to install all the software and R packages needed to reproduce the repos code using a Github Codespace. See the README.md for more information.",
    "crumbs": [
      "Github",
      "Tutorials",
      "Templates"
    ]
  },
  {
    "objectID": "gh/templates.html#r-github-template",
    "href": "gh/templates.html#r-github-template",
    "title": "Templates",
    "section": "",
    "text": "This is a Github repo template for R projects. It has renv set up and a .devcontainer for reproducibility\n\n\n\nSelect Use Template &gt; NW-PaGe/R_template when creating a new repo in the NW-PaGe org. The template comes with a pre-filled README.md file that you can edit to your own needs. It’s recommended to leave the .devconainter folder in this repo. It serves as instructions to install all the software and R packages needed to reproduce the repos code using a Github Codespace. See the README.md for more information.",
    "crumbs": [
      "Github",
      "Tutorials",
      "Templates"
    ]
  },
  {
    "objectID": "gh/templates.html#purpledoc-quarto-template",
    "href": "gh/templates.html#purpledoc-quarto-template",
    "title": "Templates",
    "section": "Purpledoc Quarto Template",
    "text": "Purpledoc Quarto Template\nThis is a Quarto template that contains the style and images used in this site\n\n\n\nquarto use template coe-test-org/purpledoc\nThis will install the extension and create an example qmd file that you can use as a starting place for your report.\nYou may also use this format with an existing Quarto project or document. From the quarto project or document directory, run the following command to install this format:\nquarto add coe-test-org/purpledoc",
    "crumbs": [
      "Github",
      "Tutorials",
      "Templates"
    ]
  },
  {
    "objectID": "gh/release.html",
    "href": "gh/release.html",
    "title": "Release Cycles",
    "section": "",
    "text": "Summary\n\nGithub Releases\nHelps devs and end users\nChangelogs and semantic versioning\nAutomate the release process",
    "crumbs": [
      "Github",
      "Tutorials",
      "Release Cycles"
    ]
  },
  {
    "objectID": "gh/release.html#github-action-for-auto-releases",
    "href": "gh/release.html#github-action-for-auto-releases",
    "title": "Release Cycles",
    "section": "Github Action for auto releases",
    "text": "Github Action for auto releases\nI recommend first creating a test repo for this. In the repo, create a Github Action workflow called changelog.yml. You can copy the full file below:\n\n\n\n.github/workflows/changelog.yml\n\nname: Changelog\non:\n  push:\n    branches:\n      - main\n\njobs:\n  changelog:\n    runs-on: ubuntu-latest\n    \n    permissions:\n      # write permission is required to create a github release\n      contents: write\n\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Conventional Changelog Action\n        id: changelog\n        uses: TriPSs/conventional-changelog-action@v3\n        with:\n          github-token: ${{ secrets.github_token }}\n          create-summary: true\n\n      - name: Create Release\n        uses: actions/create-release@v1\n        if: ${{ steps.changelog.outputs.skipped == 'false' }}\n        env:\n          GITHUB_TOKEN: ${{ secrets.github_token }}\n        with:\n          prerelease: false\n          tag_name: ${{ steps.changelog.outputs.tag }}\n          release_name: ${{ steps.changelog.outputs.tag }}\n          body: ${{ steps.changelog.outputs.clean_changelog }}",
    "crumbs": [
      "Github",
      "Tutorials",
      "Release Cycles"
    ]
  },
  {
    "objectID": "gh/reproduce.html",
    "href": "gh/reproduce.html",
    "title": "Reproducibility",
    "section": "",
    "text": "Objectives\n\nData and Code Democratization\nGithub Codespaces\nPackage reproducibility with virtual environments\nGithub Releases\nDocumentation",
    "crumbs": [
      "Github",
      "Policies",
      "Reproducibility"
    ]
  },
  {
    "objectID": "gh/reproduce.html#open-a-codespace",
    "href": "gh/reproduce.html#open-a-codespace",
    "title": "Reproducibility",
    "section": "2.1 Open a Codespace",
    "text": "2.1 Open a Codespace\nAt the root of the repo, click on the Code drop down button\n\nOn the right there is a tab called Codespaces.\nClick the + sign and a Codespace will launch\n\n\n\n\nopen up a codespace\n\n\nThis will open up a VS Code window in your browser. There are also options to open up a Jupyter Notebook or Jetbrains IDE (Pycharm). You can also install an Rstudio IDE into the codespace. It will look something like this - note that the repository is already linked and checked out into the codespace:\n\n\n\nVS Code IDE in Github Codespaces\n\n\nHere you can install most software. You can also customize the Codespace so that whenever someone opens one in your repo it will come with software pre-installed. More on that in the devcontainers section",
    "crumbs": [
      "Github",
      "Policies",
      "Reproducibility"
    ]
  },
  {
    "objectID": "gh/reproduce.html#devcontainers",
    "href": "gh/reproduce.html#devcontainers",
    "title": "Reproducibility",
    "section": "2.2 Devcontainers",
    "text": "2.2 Devcontainers\nDevcontainers are a way to install software into a Codespace so that whenever a user opens up the Codespace they won’t need to install anything themselves. Making a container can be a little tricky, so we’ve made Github templates that have devcontainers already made. See templates. There are R, Python, and general default templates. These containers will install R, Rstudio, Python, and all the packages in the repo’s virtual environments (venv, conda, pip, renv, etc) so that the user can run all the code in your repo within a couple minutes.\nTo set up a devcontainer for yourself;\n\nClick on `Code &gt; Codespaces &gt; Configure dev container\n\n\n\nThis will make a folder named .devcontainer at the root of your repo\nIn that folder it will make a file named devcontainer.json\nOn the right there is a searchable marketplace for software to add to your container\n\n\n\nEach one comes with instructions on how to add the software to the .devcontainer.json\n\nFor more information about Codespaces, see the guides here",
    "crumbs": [
      "Github",
      "Policies",
      "Reproducibility"
    ]
  },
  {
    "objectID": "gh/index.html",
    "href": "gh/index.html",
    "title": "Github Policies",
    "section": "",
    "text": "Policies and Rules\nNW-PaGe Github policies\n\nQuickstart Guide\nCode Contribution Guide\nRepo Security Rules\nLicensing\nOrganization Requirements\nCode Requirements\n\n\n\n\n\n\nTutorials\nNW-PaGe Github repo tutorials\n\nRelease Cycles\nVirtual Environments\nGithub and Quarto Templates\nGit Basics\nRepo Documentation/Github Pages and Quarto",
    "crumbs": [
      "Github"
    ]
  },
  {
    "objectID": "aws/aws_index.html",
    "href": "aws/aws_index.html",
    "title": "something",
    "section": "",
    "text": "something\nhere",
    "crumbs": [
      "AWS",
      "something"
    ]
  },
  {
    "objectID": "tools/git.html",
    "href": "tools/git.html",
    "title": "Git",
    "section": "",
    "text": "Intro\nShowing how to create and work off of a feature branch using git and github.\n\n\nBefore writing code\nFirst check to see if your main branch is up to date and has the most recent commits added. This should be the first thing you do before running/writing any code.\ngit status will tell you:\n\nWhich branch you are in\nIf your local branch is up to date when comparing to that branch in the remote repo\nIf you have any files waiting to be committed\n\ngit fetch will:\n\nRefresh your branch\nSearch for any differences between your local clone and the repo in github. If there are changes, it will display a message\n\ngit pull will pull all the changes in the remote repo into your local clone branch\n \n\ngit status\n\nOn branch main\nYour branch is up to date with 'origin/main'.\n\nChanges to be committed:\n  (use \"git restore --staged &lt;file&gt;...\" to unstage)\n    new file:   images/gitdesk.gif\n    new file:   images/gitdesk23-01.gif\n    new file:   images/gitdesk23.gif\n    new file:   images/gitdesk233-01.gif\n    new file:   images/gitdesk233.gif\n    new file:   images/gitdesk2333-01.gif\n    new file:   images/gitdesk2333.gif\n\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n    modified:   git.qmd\n\nUntracked files:\n  (use \"git add &lt;file&gt;...\" to include in what will be committed)\n    ../nul\n    git.rmarkdown\n\n\n \n\ngit fetch\n\n \n\ngit pull\n\nAlready up to date.\n\n\nIt’s the same in the git desktop app. Make sure you are in the branch you want to be in, then click fetch and pull to update that branch to include the most recent commits in the remote repo\n\n\n\nSwitch to feature branch\nIf we want to make changes to code, first make a new branch off the main.\ngit branch will show all the branches in the repo and the one you are currently in\ngit checkout -b new-branch-name will create a new branch. In this case, we already have our feature branch called test-dcipher-cases\ngit checkout branch-name will switch to a branch. In this case we can switch to test-dcipher-cases\n\ngit branch\n\n  listings\n* main\n\n\n\ngit checkout test-dcipher-cases\n\nOr in the desktop app\n\n\n\nMaking changes\nIf we want to make a change to the code, make a new branch off of test-dcipher-cases and switch to that branch\n\n\ngit checkout -b test-frank2\n\n\nand in the desktop app:\n\n\n\n\nCommitting changes to the feature branch\nNow you can make changes in your R script and when you save them they will be ready to be committed to this new branch.\ngit add to stage your changes\ngit commit -am \"messge\" to commit those changes to the new branch with a message\ngit push --set-upstream origin test-dcipher-cases to push those changes to the remote repo on the new branch\n\ngit add\n\ngit commit -am \"this is a test- pls delete\"\n\ngit push --set-upstream origin test-dcipher-cases\n\n\n\n\n\nMaking a pull request\nThis part happens in github.\n\nSelect who you want to review your code and assign yourself.\nUse labels to tag what this pull request refers to (very helpful in search for changes when managing the project) and\nAdd a milestone if it applies.\n\nThis should automatically send an email to the reviewers that there is code needed to be merged to a branch.\n\n\n\nFor Reviewers\nWhen reviewing changes, make sure the commit/changes are being merged to the correct branch.\nGithub automatically compares to the main branch, so you will have to manually click on the base branch and change it to test-dcipher-cases"
  },
  {
    "objectID": "tools/templates.html",
    "href": "tools/templates.html",
    "title": "Templates",
    "section": "",
    "text": "This is a Github repo template for R projects. It has renv set up and a .devcontainer for reproducibility\n\n\n\nSelect Use Template &gt; NW-PaGe/R_template when creating a new repo in the NW-PaGe org. The template comes with a pre-filled README.md file that you can edit to your own needs. It’s recommended to leave the .devconainter folder in this repo. It serves as instructions to install all the software and R packages needed to reproduce the repos code using a Github Codespace. See the README.md for more information."
  },
  {
    "objectID": "tools/templates.html#r-github-template",
    "href": "tools/templates.html#r-github-template",
    "title": "Templates",
    "section": "",
    "text": "This is a Github repo template for R projects. It has renv set up and a .devcontainer for reproducibility\n\n\n\nSelect Use Template &gt; NW-PaGe/R_template when creating a new repo in the NW-PaGe org. The template comes with a pre-filled README.md file that you can edit to your own needs. It’s recommended to leave the .devconainter folder in this repo. It serves as instructions to install all the software and R packages needed to reproduce the repos code using a Github Codespace. See the README.md for more information."
  },
  {
    "objectID": "tools/templates.html#purpledoc-quarto-template",
    "href": "tools/templates.html#purpledoc-quarto-template",
    "title": "Templates",
    "section": "Purpledoc Quarto Template",
    "text": "Purpledoc Quarto Template\nThis is a Quarto template that contains the style and images used in this site\n\n\n\nquarto use template coe-test-org/purpledoc\nThis will install the extension and create an example qmd file that you can use as a starting place for your report.\nYou may also use this format with an existing Quarto project or document. From the quarto project or document directory, run the following command to install this format:\nquarto add coe-test-org/purpledoc"
  },
  {
    "objectID": "tools/release.html",
    "href": "tools/release.html",
    "title": "Release Cycles",
    "section": "",
    "text": "Summary\n\nGithub Releases\nHelps devs and end users\nChangelogs and semantic versioning\nAutomate the release process"
  },
  {
    "objectID": "tools/release.html#github-action-for-auto-releases",
    "href": "tools/release.html#github-action-for-auto-releases",
    "title": "Release Cycles",
    "section": "Github Action for auto releases",
    "text": "Github Action for auto releases\nI recommend first creating a test repo for this. In the repo, create a Github Action workflow called changelog.yml. You can copy the full file below:\n\n\n\n\n.github/workflows/changelog.yml\n\nname: Changelog\non:\n  push:\n    branches:\n      - main\n\njobs:\n  changelog:\n    runs-on: ubuntu-latest\n    \n    permissions:\n      # write permission is required to create a github release\n      contents: write\n\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Conventional Changelog Action\n        id: changelog\n        uses: TriPSs/conventional-changelog-action@v3\n        with:\n          github-token: ${{ secrets.github_token }}\n          create-summary: true\n\n      - name: Create Release\n        uses: actions/create-release@v1\n        if: ${{ steps.changelog.outputs.skipped == 'false' }}\n        env:\n          GITHUB_TOKEN: ${{ secrets.github_token }}\n        with:\n          prerelease: false\n          tag_name: ${{ steps.changelog.outputs.tag }}\n          release_name: ${{ steps.changelog.outputs.tag }}\n          body: ${{ steps.changelog.outputs.clean_changelog }}"
  },
  {
    "objectID": "tools/index.html",
    "href": "tools/index.html",
    "title": "Guides and Templates",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\nDate\n\n\nTitle\n\n\nAuthor\n\n\nReading Time\n\n\n\n\n\n\n\n\n\nSep 1, 2023\n\n\nCode and Repo Documentation\n\n\nFrank Aragona\n\n\n13 min\n\n\n\n\n\n\n\nFeb 1, 2023\n\n\nGit\n\n\nFrank Aragona\n\n\n3 min\n\n\n\n\n\n\n\nAug 16, 2024\n\n\nLink external R code to the documentation\n\n\nFrank Aragona\n\n\n1 min\n\n\n\n\n\n\n\nSep 1, 2023\n\n\nPackage Documentation\n\n\nFrank Aragona\n\n\n1 min\n\n\n\n\n\n\n\nSep 1, 2023\n\n\nRelease Cycles\n\n\nFrank Aragona\n\n\n6 min\n\n\n\n\n\n\n\nSep 1, 2023\n\n\nTemplates\n\n\nFrank Aragona\n\n\n1 min\n\n\n\n\n\n\n\nFeb 1, 2023\n\n\nVirtual Environments\n\n\nFrank Aragona\n\n\n11 min\n\n\n\n\n\nNo matching items"
  }
]